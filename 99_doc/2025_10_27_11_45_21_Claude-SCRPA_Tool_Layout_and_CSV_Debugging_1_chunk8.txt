I assumed that the chart, map/map placeholder that state no reported incidents in the 7Day cycle and the area under the title **Pattern Offenders/Suspects** would have the charts map/map place holder and place holder for the **Pattern Offenders/Suspects** placed in the correct spot as in over the existing chart, map and in the area under the **Pattern Offenders/Suspects** title



## Response:
6/22/2025, 6:07:14 PM



**SCRPA PowerPoint Template Fixes & Block Code Integration** ‚àô Version 3

````markdown
# üïí 2025-06-22-22-35-00
# SCRPA_Place_and_Time/complete_scrpa_fixes
# Author: R. A. Carucci
# Purpose: Complete SCRPA fixes with Block M code integration, map extent, and PowerPoint automation

## üéØ **COMPLETE SOLUTION - ALL FIXES**

Perfect! I see the City Boundaries layer and understand exactly what's needed. Here's the complete solution:

### **1. Block M Code Integration**
Your block extraction code is exactly what we need! Here's the integration:

#### **Updated Incident Table Processing:**
```python
# üïí 2025-06-22-22-35-00  
# SCRPA_Place_and_Time/incident_table_enhanced.py
# Author: R. A. Carucci
# Purpose: Enhanced incident table with proper Block M code formatting

import sys
import os
sys.path.append(os.path.dirname(__file__))
from extract_block_from_address import extract_block_and_type

def get_proper_block_address(incident_data):
    """
    Use your Block M code to extract proper block format
    """
    try:
        # Try to get FullAddress2 or fulladdr field
        address_fields = ['FullAddress2', 'fulladdr', 'FULLADDR', 'address', 'ADDRESS']
        
        raw_address = None
        for field in address_fields:
            if field in incident_data and incident_data[field]:
                raw_address = incident_data[field]
                break
        
        if raw_address:
            # Apply your Block M code logic
            block_value, block_type = extract_block_and_type(raw_address)
            
            if block_value and block_type == "BLOCK":
                return block_value  # Returns "100 BLOCK" format
            elif block_type == "INTERSECTION":
                return "INTERSECTION"
            elif block_type == "PO BOX":
                return "PO BOX"
            else:
                return extract_street_name_from_address(raw_address)
        
        # Fallback to coordinates if no address
        return f"COORDINATES: {incident_data.get('x', 'Unknown')}, {incident_data.get('y', 'Unknown')}"
        
    except Exception as e:
        return "ADDRESS UNAVAILABLE"

def extract_street_name_from_address(address):
    """
    Extract street name when no number is available
    """
    import re
    
    # Remove common prefixes and clean up
    cleaned = re.sub(r'^(THE\s+|A\s+)', '', address.upper().strip())
    
    # Take first significant part as street name
    parts = cleaned.split()
    if len(parts) >= 2:
        return f"{parts[0]} {parts[1]} AREA"
    elif len(parts) == 1:
        return f"{parts[0]} AREA"
    else:
        return "UNKNOWN LOCATION"
```

### **2. Map Extent Fix with City Boundaries**
Based on your City Boundaries layer screenshot:

```python
def calculate_optimal_map_extent_with_city_bounds(target_layer, map_frame, map_obj):
    """
    Calculate optimal extent showing incidents with city boundaries visible
    Uses City Boundaries layer as reference
    """
    try:
        import arcpy
        
        # Find City Boundaries layer
        city_boundaries_layer = None
        for lyr in map_obj.listLayers():
            if "City Boundaries" in lyr.name or "Boundaries" in lyr.name:
                city_boundaries_layer = lyr
                break
        
        # Get incident extent
        incident_desc = arcpy.Describe(target_layer)
        incident_count = int(arcpy.GetCount_management(target_layer).getOutput(0))
        
        if incident_count == 0:
            # No incidents - show city boundaries
            if city_boundaries_layer:
                city_extent = arcpy.Describe(city_boundaries_layer).extent
                map_frame.camera.setExtent(city_extent)
            return True
        
        incident_extent = incident_desc.extent
        
        if incident_count == 1:
            # Single incident - create buffer around point
            center_x = (incident_extent.XMin + incident_extent.XMax) / 2
            center_y = (incident_extent.YMin + incident_extent.YMax) / 2
            
            # 1000 foot buffer around single incident (adjust as needed)
            buffer_size = 1000  # feet
            
            new_extent = arcpy.Extent(
                center_x - buffer_size,
                center_y - buffer_size,
                center_x + buffer_size,
                center_y + buffer_size
            )
        else:
            # Multiple incidents - buffer around all
            width_buffer = incident_extent.width * 0.3
            height_buffer = incident_extent.height * 0.3
            
            new_extent = arcpy.Extent(
                incident_extent.XMin - width_buffer,
                incident_extent.YMin - height_buffer,
                incident_extent.XMax + width_buffer,
                incident_extent.YMax + height_buffer
            )
        
        # Ensure city boundaries are visible by checking if extent is too small
        if city_boundaries_layer:
            city_extent = arcpy.Describe(city_boundaries_layer).extent
            
            # If calculated extent is much smaller than city, expand it
            if (new_extent.width < city_extent.width * 0.2 or 
                new_extent.height < city_extent.height * 0.2):
                
                # Expand to show more city context
                expansion_factor = 1.5
                center_x = (new_extent.XMin + new_extent.XMax) / 2
                center_y = (new_extent.YMin + new_extent.YMax) / 2
                
                new_width = city_extent.width * 0.4  # Show 40% of city
                new_height = city_extent.height * 0.4
                
                new_extent = arcpy.Extent(
                    center_x - new_width/2,
                    center_y - new_height/2,
                    center_x + new_width/2,
                    center_y + new_height/2
                )
        
        # Apply the calculated extent
        map_frame.camera.setExtent(new_extent)
        
        print(f"‚úÖ Map extent set for {incident_count} incidents")
        return True
        
    except Exception as e:
        print(f"‚ùå Extent calculation failed: {e}")
        return False
```

### **3. PowerPoint Template - NO Changes Needed! **
You're absolutely right! The template is perfect as-is. The script should:
- **Chart**: Replace existing chart by overlaying with exact positioning
- **Map**: Replace existing map by overlaying with exact positioning  
- **Pattern Offenders/Suspects**: Insert table image in that area

#### **Enhanced PowerPoint Auto-Assembly:**
```python
def auto_assemble_powerpoint_with_positioning(output_folder, crime_types):
    """
    Replace existing elements by positioning new images exactly over them
    No template changes needed!
    """ try:
        from pptx import Presentation
        from pptx.util import Inches
        import glob
        
        # Find PowerPoint file
        ppt_files = glob.glob(os.path.join(output_folder, "*.pptx"))
        if not ppt_files:
            print("‚ùå No PowerPoint file found")
            return False
            
        prs = Presentation(ppt_files[0])
        print(f"‚úÖ Loaded PowerPoint: {os.path.basename(ppt_files[0])}")
        
        for i, crime_type in enumerate(crime_types):
            if i >= len(prs.slides):
                continue
                
            slide = prs.slides[i]
            crime_folder = get_crime_type_folder(crime_type, get_date_string())
            filename_prefix = get_standardized_filename(crime_type)
            
            print(f"üìä Processing slide {i+1}: {crime_type}")
            
            # Position for chart (right side, top)
            # Adjust these coordinates based on your template layout
            chart_left = Inches(6.0)   # Adjust based on your layout
            chart_top = Inches(2.0)    # Adjust based on your layout
            chart_width = Inches(5.84)
            chart_height = Inches(4.00)
            
            # Position for map (right side, bottom or wherever your map is)
            map_left = Inches(6.0)     # Adjust based on your layout
            map_top = Inches(6.5)      # Adjust based on your layout  
            map_width = Inches(5.60)
            map_height = Inches(4.03)
            
            # Position for incident table (under Pattern Offenders/Suspects)
            table_left = Inches(6.0)   # Adjust based on your layout
            table_top = Inches(1.0)    # Adjust based on your layout
            table_width = Inches(8.33)
            table_height = Inches(1.98)
            
            # Add chart
            chart_path = os.path.join(crime_folder, f"{filename_prefix}_Chart.png")
            if os.path.exists(chart_path):
                slide.shapes.add_picture(
                    chart_path, chart_left, chart_top, chart_width, chart_height
                )
                print(f"  ‚úÖ Added chart: {filename_prefix}_Chart.png")
            
            # Add map
            map_path = os.path.join(crime_folder, f"{filename_prefix}_Map.png")
            if os.path.exists(map_path):
                slide.shapes.add_picture(
                    map_path, map_left, map_top, map_width, map_height
                )
                print(f"  ‚úÖ Added map: {filename_prefix}_Map.png")
            
            # Add incident table (try AutoFit first, then placeholder)
            table_paths = [
                os.path.join(crime_folder, f"{filename_prefix}_IncidentTable_AutoFit.png"),
                os.path.join(crime_folder, f"{filename_prefix}_IncidentTable_Placeholder.png")
            ]
            
            for table_path in table_paths:
                if os.path.exists(table_path):
                    slide.shapes.add_picture(
                        table_path, table_left, table_top, table_width, table_height
                    )
                    print(f"  ‚úÖ Added incident table: {os.path.basename(table_path)}")
                    break
        
        # Save updated presentation
        prs.save(ppt_files[0])
        print(f"‚úÖ PowerPoint assembly completed: {os.path.basename(ppt_files[0])}")
        return True
        
    except Exception as e:
        print(f"‚ùå PowerPoint assembly failed: {e}")
        import traceback
        traceback.print_exc()
        return False

def get_date_string():
    """Helper to get current date string"""
    from datetime import date
    return date.today().strftime("%Y_%m_%d")
```

### **4. Updated Map Export with All Fixes:**
```python
def export_maps_enhanced(crime_type, output_folder, args):
    """
    Enhanced map export with:
    - Proper extent calculation
    - City boundaries visibility
    - Block M code integration for any text elements
    """
    try:
        # ... existing map export logic ...
        
        # After getting the target layer, apply new extent calculation
        if target_layer:
            # Apply optimal extent with city boundaries
            calculate_optimal_map_extent_with_city_bounds(target_layer, map_frame, map_obj)
            
            # Rest of existing export logic...
            
        return export_map_to_png(layout, crime_type, crime_output_folder, filename_prefix)
        
    except Exception as e:
        print(f"‚ùå Enhanced map export failed: {e}")
        return False
```

---

## üìã **IMPLEMENTATION STEPS**

### **Step 1: PowerPoint Template Update** ‚è∞ *30 minutes*
1. **Open template file**: `SCRPA_REPORT.pptx`
2. **Delete existing objects**: Charts, maps, pattern analysis content
3. **Create placeholder rectangles** with exact dimensions:
   - Pattern table: 8.33" √ó 1.98"
   - Chart: 5.84" √ó 4.00"  
   - Map: 5.60" √ó 4.03"
4. **Add placeholder text** to each shape
5. **Distribute horizontally** and align to slide
6. **Save template**

### **Step 2: Block M Code Integration** ‚è∞ *45 minutes*
1. **Add Block formatting function** to `incident_table_automation.py`
2. **Update CSV export** to use proper Block format
3. **Test with sample addresses** to verify formatting
4. **Ensure backward compatibility** with coordinate fallback

### **Step 3: Map Extent Enhancement** ‚è∞ *30 minutes*
1. **Add extent calculation** to `map_export.py`
2. **Test with MV Theft data** to ensure proper zoom
3. **Verify city boundaries** are visible
4. **Apply to all crime types**

### **Step 4: PowerPoint Assembly** ‚è∞ *60 minutes*
1. **Implement placeholder replacement** function
2. **Test with generated images** at exact dimensions
3. **Verify positioning** and alignment
4. **Test with multiple crime types**

---

## üéØ **SUCCESS CRITERIA**

- **CSV shows**: "100 BLOCK MAIN ST" instead of "BLOCK 82424995"
- **Maps display**: Appropriate zoom with city boundaries visible
- **PowerPoint**: Clean assembly with no overlapping elements
- **Incident tables**: Auto-generated at exact 8.33" √ó 1.98" dimensions
- **All elements**: Properly positioned and formatted

---

## ‚ö†Ô∏è **QUESTIONS FOR YOU**

1. **Block M Code**: Can you provide the specific Block M code logic for address formatting? 2. **PowerPoint Template**: Should I provide the exact PowerPoint template modification steps, or would you prefer to handle the template changes manually? 3. **City Boundaries Layer**: What's the exact name of the city boundaries layer in your ArcGIS project? 4. **Placeholder Text**: Are the suggested placeholder texts ("INSERT_CHART_HERE") acceptable, or do you prefer different text? ---

**Ready to implement these fixes once you confirm the Block M code details and template modification approach! **
````

**artifacts**

*Request*

````javascript
{
  "id": "scrpa_powerpoint_fixes",
  "command": "update",
  "new_str": "### **5. Complete Integration Code**\nHere's the complete updated code to add to your existing files:\n\n#### **A. Add to `incident_table_automation.py`:**\n```python\n# Add this import at the top\nfrom extract_block_from_address import extract_block_and_type\n\n# Replace the existing get_7day_incident_details function with this enhanced version:\ndef get_7day_incident_details_enhanced(crime_type, target_date):\n    \"\"\"\n    Extract detailed incident information with proper Block M code formatting\n    \"\"\"\n    incidents = []\n    \n    try:\n        start_date, end_date = get_7day_period_dates(target_date)\n        \n        if not start_date or not end_date:\n            print(f\"‚ùå Could not determine Excel 7-day period for {target_date}\")\n            return incidents\n            \n        print(f\"üìÖ Getting incident details for period: {start_date} to {end_date}\")\n        \n        aprx = arcpy.mp.ArcGISProject(APR_PATH)\n        maps = aprx.listMaps()\n        \n        if not maps:\n            print(f\"‚ùå No maps found in project\")\n            return incidents\n            \n        map_obj = maps[0]\n        layer_name = f\"{crime_type} 7-Day\"\n        target_layer = None\n        \n        for lyr in map_obj.listLayers():\n            if lyr.name == layer_name:\n                target_layer = lyr\n                break\n        \n        if not target_layer:\n            print(f\"‚ùå 7-Day layer not found: {layer_name}\")\n            return incidents\n        \n        # Build SQL filter\n        from map_export import build_sql_filter_7day_excel\n        filter_sql = build_sql_filter_7day_excel(crime_type, start_date, end_date)\n        \n        if filter_sql:\n            original_query = target_layer.definitionQuery\n            target_layer.definitionQuery = filter_sql\n            \n            try:\n                # Updated field list to include address fields\n                fields = [\"calldate\", \"fulladdr\", \"FullAddress2\", \"calltype\", \"disposition\", \"SHAPE@XY\"]\n                \n                with arcpy.da.SearchCursor(target_layer, fields) as cursor:\n                    for row in cursor:\n                        try:\n                            calldate = row[0]\n                            fulladdr = row[1] if row[1] else \"\"\n                            fulladdress2 = row[2] if row[2] else \"\"\n                            calltype = row[3] if row[3] else \"Unknown\"\n                            disposition = row[4] if row[4] else \"Unknown\"\n                            coordinates = row[5] if row[5] else (0, 0)\n                            \n                            # Use Block M code for proper address formatting\n                            address_to_process = fulladdress2 or fulladdr\n                            if address_to_process:\n                                block_value, block_type = extract_block_and_type(address_to_process)\n                                if block_value and block_type == \"BLOCK\":\n                                    formatted_block = block_value\n                                elif block_type == \"INTERSECTION\":\n                                    formatted_block = \"INTERSECTION\"\n                                elif block_type == \"PO BOX\":\n                                    formatted_block = \"PO BOX\"\n                                else:\n                                    # Extract street name for non-numbered addresses\n                                    formatted_block = extract_street_from_address(address_to_process)\n                            else:\n                                # Fallback to coordinates\n                                formatted_block = f\"COORDINATES: {coordinates[0]:.0f}, {coordinates[1]:.0f}\"\n                            \n                            if isinstance(calldate, datetime):\n                                incident = {\n                                    'block': formatted_block,  # Now properly formatted!\n                                    'incident_date': calldate.strftime('%m/%d/%y'),\n                                    'day_of_week': calldate.strftime('%A'),\n                                    'time_period': get_time_period_from_hour(calldate.hour),\n                                    'time_of_day': calldate.strftime('%H:%M'),\n                                    'raw_datetime': calldate,\n                                    'vehicle_description': '[MANUAL ENTRY]',\n                                    'suspect_description': '[MANUAL ENTRY]',\n                                    'narrative_summary': '[MANUAL ENTRY]'\n                                }\n                                \n                                incidents.append(incident)\n                                \n                        except Exception as e:\n                            print(f\"  ‚ö†Ô∏è Error processing incident record: {e}\")\n                            continue\n                \n                target_layer.definitionQuery = original_query\n                incidents.sort(key=lambda x: x['raw_datetime'])\n                print(f\"‚úÖ Extracted {len(incidents)} incident details for {crime_type}\")\n                \n            except Exception as e:\n                print(f\"‚ùå Error extracting incident details: {e}\")\n                \n        del aprx\n        \n    except Exception as e:\n        print(f\"‚ùå Error accessing incident data for {crime_type}: {e}\")\n    \n    return incidents\n\ndef extract_street_from_address(address):\n    \"\"\"\n    Extract street name when Block M code doesn't return a block number\n    \"\"\"\n    import re\n    \n    if not address:\n        return \"UNKNOWN LOCATION\"\n        \n    # Clean up the address\n    cleaned = address.upper().strip()\n    \n    # Remove common prefixes\n    cleaned = re.sub(r'^(THE\\s+|A\\s+)', '', cleaned)\n    \n    # Split into parts and take significant ones\n    parts = cleaned.split()\n    if len(parts) >= 2:\n        return f\"{parts[0]} {parts[1]} AREA\"\n    elif len(parts) == 1:\n        return f\"{parts[0]} AREA\"\n    else:\n        return \"UNKNOWN LOCATION\"\n```\n\n#### **B. Add to `map_export.py`:**\n```python\n# Add this function to map_export.py\ndef calculate_optimal_map_extent_with_city_bounds(target_layer, map_frame, map_obj):\n    \"\"\"\n    Calculate optimal extent showing incidents with city boundaries visible\n    Uses City Boundaries layer as reference for context\n    \"\"\"\n    try:\n        import arcpy\n        \n        # Find City Boundaries layer\n        city_boundaries_layer = None\n        for lyr in map_obj.listLayers():\n            if \"City Boundaries\" in lyr.name or \"Boundaries\" in lyr.name:\n                city_boundaries_layer = lyr\n                break\n        \n        # Get incident data\n        incident_count = int(arcpy.GetCount_management(target_layer).getOutput(0))\n        \n        if incident_count == 0:\n            # No incidents - show city boundaries\n            if city_boundaries_layer:\n                city_extent = arcpy.Describe(city_boundaries_layer).extent\n                map_frame.camera.setExtent(city_extent)\n                arcpy.AddMessage(\"üìç Set extent to city boundaries (no incidents)\")\n            return True\n        \n        incident_extent = arcpy.Describe(target_layer).extent\n        \n        if incident_count == 1:\n            # Single incident - create appropriate buffer\n            center_x = (incident_extent.XMin + incident_extent.XMax) / 2\n            center_y = (incident_extent.YMin + incident_extent.YMax) / 2\n            \n            # 2000-foot buffer for single incident (good for neighborhood context)\n            buffer_size = 2000\n            \n            new_extent = arcpy.Extent(\n                center_x - buffer_size,\n                center_y - buffer_size,\n                center_x + buffer_size,\n                center_y + buffer_size\n            )\n            \n            arcpy.AddMessage(f\"üìç Single incident: 2000ft buffer around point\")\n            \n        else:\n            # Multiple incidents - buffer around all with 25% margin\n            width_buffer = max(incident_extent.width * 0.25, 1000)  # Minimum 1000ft buffer\n            height_buffer = max(incident_extent.height * 0.25, 1000)\n            \n            new_extent = arcpy.Extent(\n                incident_extent.XMin - width_buffer,\n                incident_extent.YMin - height_buffer,\n                incident_extent.XMax + width_buffer,\n                incident_extent.YMax + height_buffer\n            )\n            \n            arcpy.AddMessage(f\"üìç Multiple incidents: 25% buffer around extent\")\n        \n        # Ensure reasonable minimum size using city boundaries as reference\n        if city_boundaries_layer:\n            city_extent = arcpy.Describe(city_boundaries_layer).extent\n            \n            # If calculated extent is too small compared to city, expand it\n            if (new_extent.width < city_extent.width * 0.15 or \n                new_extent.height < city_extent.height * 0.15):\n                \n                # Expand to show meaningful city context\n                center_x = (new_extent.XMin + new_extent.XMax) / 2\n                center_y = (new_extent.YMin + new_extent.YMax) / 2\n                \n                # Use 20% of city size as minimum viewing area\n                min_width = city_extent.width * 0.2\n                min_height = city_extent.height * 0.2\n                \n                new_extent = arcpy. ",
  "version_uuid": "129c7d22-3c06-4547-94c3-84c63781c067"
}
````



## Prompt:
6/22/2025, 6:07:33 PM

Continue



## Response:
6/22/2025, 6:08:25 PM



**SCRPA PowerPoint Template Fixes & Block Code Integration** ‚àô Version 4

````markdown
# üïí 2025-06-22-22-35-00
# SCRPA_Place_and_Time/complete_scrpa_fixes
# Author: R. A. Carucci
# Purpose: Complete SCRPA fixes with Block M code integration, map extent, and PowerPoint automation

## üéØ **COMPLETE SOLUTION - ALL FIXES**

Perfect! I see the City Boundaries layer and understand exactly what's needed. Here's the complete solution:

### **1. Block M Code Integration**
Your block extraction code is exactly what we need! Here's the integration:

#### **Updated Incident Table Processing:**
```python
# üïí 2025-06-22-22-35-00  
# SCRPA_Place_and_Time/incident_table_enhanced.py
# Author: R. A. Carucci
# Purpose: Enhanced incident table with proper Block M code formatting

import sys
import os
sys.path.append(os.path.dirname(__file__))
from extract_block_from_address import extract_block_and_type

def get_proper_block_address(incident_data):
    """
    Use your Block M code to extract proper block format
    """
    try:
        # Try to get FullAddress2 or fulladdr field
        address_fields = ['FullAddress2', 'fulladdr', 'FULLADDR', 'address', 'ADDRESS']
        
        raw_address = None
        for field in address_fields:
            if field in incident_data and incident_data[field]:
                raw_address = incident_data[field]
                break
        
        if raw_address:
            # Apply your Block M code logic
            block_value, block_type = extract_block_and_type(raw_address)
            
            if block_value and block_type == "BLOCK":
                return block_value  # Returns "100 BLOCK" format
            elif block_type == "INTERSECTION":
                return "INTERSECTION"
            elif block_type == "PO BOX":
                return "PO BOX"
            else:
                return extract_street_name_from_address(raw_address)
        
        # Fallback to coordinates if no address
        return f"COORDINATES: {incident_data.get('x', 'Unknown')}, {incident_data.get('y', 'Unknown')}"
        
    except Exception as e:
        return "ADDRESS UNAVAILABLE"

def extract_street_name_from_address(address):
    """
    Extract street name when no number is available
    """
    import re
    
    # Remove common prefixes and clean up
    cleaned = re.sub(r'^(THE\s+|A\s+)', '', address.upper().strip())
    
    # Take first significant part as street name
    parts = cleaned.split()
    if len(parts) >= 2:
        return f"{parts[0]} {parts[1]} AREA"
    elif len(parts) == 1:
        return f"{parts[0]} AREA"
    else:
        return "UNKNOWN LOCATION"
```

### **2.