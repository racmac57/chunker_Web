If it's empty, delete the legend and insert a new one:

Insert ‚Üí Legend ‚Üí Click on the layout

ArcGIS will auto-attach visible layers

üõ† Fix 3: Enable Dynamic Extent (Optional)
If the map frame is frozen at a fixed scale or position:

Right-click the map frame ‚Üí Properties

In the Display tab, uncheck ‚ÄúFixed Extent‚Äù if it's enabled. Would you like me to walk you through those in ArcGIS Pro, or help update the script to force visibility and frame refresh automatically? Provide Feedback | View Changes | Contribute. You said:
Uploaded image
I named the layout "Crime_Reporting_Layout1"
ChatGPT said:
Perfect ‚Äî thanks for confirming and sharing the screenshot. ‚úÖ Observations:
Your layout is named Crime_Reporting_Layout1

The legend is correctly populating and showing layer symbology

The map is drawing correctly inside the layout frame

Layers are toggled visible and match the legend

üõ† What Needs to Be Fixed in the Script:
Your script is currently looking for the layout using:

layout = project.listLayouts("Crime_Reporting_Layout")[0]
But your actual layout is now Crime_Reporting_Layout1 ‚Äî this mismatch is the reason your exported PDFs are blank. ‚úÖ Fix:
Update your script line to:

layout = project.listLayouts("Crime_Reporting_Layout1")[0]
Alternatively, if you want the script to work more flexibly across future renames:

layout = project.listLayouts()[0]  # Grabs the first layout in the project
Make sure the layout you want is at the top of the layout list in ArcGIS Pro if you choose this method. Would you like me to help update this directly in your .py file now? Provide Feedback | View Changes | Contribute. You said:
Is this correct:

import arcpy
import pandas as pd
from datetime import datetime
import os

# Set paths
csv_path = r"C:\Users\carucci_r\OneDrive - City of Hackensack\_Hackensack_Data_Repository\Refrence\TimeSCRPT\DateRelated\7Day_28Day_Cycle_20250414.csv"
export_root = r"C:\Users\carucci_r\OneDrive - City of Hackensack\_25_SCRPA\TIME_Based\Reports"
project = arcpy.mp.ArcGISProject("CURRENT")
map_obj = project.listMaps()[0]  # Assumes one map in project

# Load cycle control table
cycle_df = pd.read_csv(csv_path)
if not any(cycle_df['Is_Due'] == True):
    raise ValueError("No cycle is marked as 'Is_Due = True' in the cycle table.") current_cycle = cycle_df[cycle_df['Is_Due'] == True].iloc[0]

# Extract dates and report name
seven_day_start = pd.to_datetime(current_cycle['7_Day_Start']).strftime('%Y-%m-%d')
seven_day_end = pd.to_datetime(current_cycle['7_Day_End']).strftime('%Y-%m-%d')
twenty_eight_day_start = pd.to_datetime(current_cycle['28_Day_Start']).strftime('%Y-%m-%d')
twenty_eight_day_end = pd.to_datetime(current_cycle['28_Day_End']).strftime('%Y-%m-%d')
ytd_start = '2024-12-31'
report_name = current_cycle['Report_Name']
report_due_date = pd.to_datetime(current_cycle['Report_Due_Date']).strftime('%Y_%m_%d')

# Create output folder for this report
report_folder = os.path.join(export_root, f"{report_name}_{report_due_date}")
os.makedirs(report_folder, exist_ok=True)

# Keyword filters for each crime type
keywords_by_crime = {
    "Burglary - Auto": ['auto'],
    "Burglary - Comm & Res": ['residence', 'commercial'],
    "Robbery": ['robbery'],
    "Sexual Offenses": ['sexual'],
    "MV Theft": ['motor vehicle theft']
}

# Construct SQL definitions
def build_sql(start_date, end_date, keywords):
    calltype_clause = " OR ".join([f"calltype LIKE '%{kw}%'" for kw in keywords])
    return (
        f"calldate >= date '{start_date}' AND calldate <= date '{end_date}' "
        f"AND disposition LIKE '%report%' AND ({calltype_clause})"
    )

def build_sql_ytd(keywords):
    calltype_clause = " OR ".join([f"calltype LIKE '%{kw}%'" for kw in keywords])
    return (
        f"calldate >= date '{ytd_start}' "
        f"AND disposition LIKE '%report%' AND ({calltype_clause})"
    )

# Map layers to definition queries
layer_query_mapping = {}
for crime, keywords in keywords_by_crime.items():
    layer_query_mapping[f"{crime} 7-Day"] = build_sql(seven_day_start, seven_day_end, keywords)
    layer_query_mapping[f"{crime} 28-Day"] = build_sql(twenty_eight_day_start, twenty_eight_day_end, keywords)
    layer_query_mapping[f"{crime} YTD"] = build_sql_ytd(keywords)

# Apply definition queries
for layer_name, query in layer_query_mapping.items():
    lyr = map_obj.listLayers(layer_name)[0]
    lyr.definitionQuery = query

# Set layout and symbology export
layout = project.listLayouts()[0]  # Grabs the first layout in the project
crime_types = list(keywords_by_crime.keys())
for crime in crime_types:
    visible_layers = []

    # Turn visibility on for this crime type
    for lyr in map_obj.listLayers():
        is_crime = crime in lyr.name
        lyr.visible = is_crime
        if is_crime:
            visible_layers.append(lyr)

    # Zoom to visible data
    extent = None
    for lyr in visible_layers:
        try:
            ext = lyr.getExtent()
            if extent:
                extent = extent.union(ext)
            else:
                extent = ext
        except:
            continue

    if extent:
        map_obj.defaultCamera.setExtent(extent)

    # Export layout
    output_path = os.path.join(report_folder, f"{crime.replace(' ', '_')}_{report_name}_{report_due_date}.pdf")
    layout.exportToPDF(output_path)

arcpy.AddMessage(f"Reports exported to: {report_folder}")
ChatGPT said:
Yes ‚Äî that script looks very well structured and nearly complete for your goal. ‚úÖ What It Does Correctly:
Loads the correct 7-Day, 28-Day, and YTD dates from your control table. Filters layers by keyword in calltype, and only if disposition contains "report". Applies the correct SQL definition queries to each layer. Toggles layer visibility per crime type and zooms to extent. Exports layouts named correctly with crime type + report name + due date. Saves them in an automatically created report folder. Uses project.listLayouts()[0] which will target the first layout (you can update this to "Crime_Reporting_Layout1" if needed). üîÅ Suggestion for Clarity & Maintenance
You may optionally want to explicitly target your layout:

layout = project.listLayouts("Crime_Reporting_Layout1")[0]
This avoids unexpected issues if the layout order changes in the project. ‚ö† If Your Output PDFs Are Still Incomplete:
Make sure the following are all true in your .aprx:

The layout name is exactly "Crime_Reporting_Layout1". The Map Frame in the layout is linked to the correct map (Map). The Legend in the layout includes all layer groups or is set to "Only show visible layers". The City Boundaries layer is always on (or scripted to toggle). You're ready to run with this version. Would you like help integrating:

Optional constant layers (e.g. City Boundaries)? Automatically refreshing the legend? Scheduling the script? Provide Feedback | View Changes | Contribute. You said:
MV_Theft_C05W18_2025_05_06.pdf
PDF
Robbery_C05W18_2025_05_06.pdf
PDF
Sexual_Offenses_C05W18_2025_05_06.pdf
PDF
I updated the code in the templet project and ran it. I got this message:

ScriptWeekly Crime Report
=====================
Tool Path

C:\GIS_Tools\CrimeAutomationTools.tbx\WeeklyCrimeReport
=====================
Parameters

=====================
Messages

Start Time: Friday, May 2, 2025 2:54:38 PM
Reports exported to: C:\Users\carucci_r\OneDrive - City of Hackensack\_25_SCRPA\TIME_Based\Reports\C05W18_2025_05_06
Succeeded at Friday, May 2, 2025 2:55:04 PM (Elapsed Time: 26.22 seconds)

I attached three of the exported layouts. Question was I suppose to run the script from the Test project? ChatGPT said:
Thanks ‚Äî the script executed successfully and generated outputs, which is great progress! üîç Review of the Exported Layouts
‚úÖ MV_Theft_C05W18_2025_05_06.pdf:
‚úÖ Heatmap layers are visible and labeled. ‚úÖ Legend includes "MV Theft 7-Day", "MV Theft 28-Day", and "MV Theft YTD" with color ramp and density labels. ‚úÖ Basemap and frame are working. ‚ùå Robbery_C05W18_2025_05_06.pdf and Sexual_Offenses_C05W18_2025_05_06.pdf:
‚ùå Map frame is empty. ‚ùå Legend is missing content. üß≠ This suggests either:

The data for those crime types didn‚Äôt match the current reporting period‚Äôs query. The layers were not correctly toggled visible before export. Their symbology didn't draw due to query mismatch or empty extent. üß† Answer to Your Question:
Were you supposed to run the script from the Test project? No, you're supposed to run it from the template project, now that it‚Äôs fully configured and renamed. That‚Äôs what you just did ‚Äî and that‚Äôs correct. ‚úÖ What to Do Next:
Open your project and test Robbery and Sexual Offenses groups manually:

Turn on each sublayer (7-Day, 28-Day, YTD)

Zoom to layer ‚Üí Do you see data on the map? If not, open each layer‚Äôs Definition Query and adjust the filter temporarily to show any matching records (e.g., just filter for disposition LIKE '%report%')

Check the attribute table for those layers:

Confirm there‚Äôs actually data returned by the current filter

If needed: I can enhance the script to skip blank layers or add fallback zoom logic. Would you like to investigate the Robbery and Sexual Offenses data now, or move on to legend automation or layout polish? Provide Feedback | View Changes | Contribute. You said:
Burglary_-_Comm_&_Res_C05W18_2025_05_06.pdf
PDF
maybe the code needs to be updated so the City Boundaries, Human Geography Dark Label, Human Geography Dark Detail and Human Geography Dark Base, remain selected for all layouts? ChatGPT said:
Yes ‚Äî you‚Äôre absolutely right to suggest that. Currently, the script only turns on layers that match a given crime type, and turns off everything else. That includes your base layers, like:

City Boundaries

Human Geography Dark Base

Human Geography Dark Detail

Human Geography Dark Label

These are essential for context and should always stay visible in every layout. ‚úÖ How to Fix It
We'll update the script to:

Always leave those basemap layers visible

Only toggle the thematic (crime) layers per cycle

üõ† Updated Visibility Section (Insert in your script):
Find this section:

for lyr in map_obj.listLayers():
    is_crime = crime in lyr.name
    lyr.visible = is_crime
    if is_crime:
        visible_layers.append(lyr)
Replace with:

# Define base layers that should always be visible
always_visible_layers = [
    "City Boundaries",
    "Human Geography Dark Base",
    "Human Geography Dark Detail",
    "Human Geography Dark Label"
]

for lyr in map_obj.listLayers():
    # Always turn on basemap layers
    if lyr.name in always_visible_layers:
        lyr.visible = True
    else:
        is_crime = crime in lyr.name
        lyr.visible = is_crime
        if is_crime:
            visible_layers.append(lyr)
Once added, run the script again ‚Äî you should see complete map context in all layouts moving forward. Let me know if you‚Äôd like to bundle this into the full script with more enhancements next. Provide Feedback | View Changes | Contribute. You said:
Burglary_-_Comm_&_Res_C05W18_2025_05_06.pdf
PDF
MV_Theft_C05W18_2025_05_06.pdf
PDF
Robbery_C05W18_2025_05_06.pdf
PDF
ScriptWeekly Crime Report
=====================
Tool Path

C:\GIS_Tools\CrimeAutomationTools.tbx\WeeklyCrimeReport
=====================
Parameters

=====================
Messages

Start Time: Friday, May 2, 2025 3:06:26 PM
Reports exported to: C:\Users\carucci_r\OneDrive - City of Hackensack\_25_SCRPA\TIME_Based\Reports\C05W18_2025_05_06
Succeeded at Friday, May 2, 2025 3:07:10 PM (Elapsed Time: 43.20 seconds)
ChatGPT said:
Thanks ‚Äî I‚Äôve reviewed the latest exported layouts. Here‚Äôs what we‚Äôre seeing:

‚úÖ What‚Äôs Working Well:
Basemap layers are now visible across all layouts (City Boundaries, Human Geography layers, etc.). MV Theft layout:

Has full map symbology and legend. ‚úÖ Layers like "MV Theft 7-Day", "28-Day", "YTD" are properly labeled. ‚úÖ Heatmap density legend is present. ‚ùå What‚Äôs Still Not Working:
Burglary - Comm & Res and Robbery layouts:

‚ùå Map content missing ‚Äì likely no matching features in this cycle. ‚ùå Legend blank ‚Äì result of no visible crime layers. üîç Likely Cause
The script zooms and exports only if features are visible for the current crime type and date filters. If no features match:

Map doesn‚Äôt zoom in

Legend remains empty

Export is technically successful, but visually blank

This is expected behavior when no data matches. ‚úÖ Recommended Next Steps
1. Confirm in ArcGIS Pro:
Open the project, turn on the layers for:

Burglary - Comm & Res 7-Day, 28-Day, YTD

Robbery 7-Day, 28-Day, YTD

Check if anything displays after removing the definition queries temporarily. This will confirm whether data exists for those layers. 2. (Optional) Update Script to Skip Blank Exports:
If you‚Äôd like, I can adjust the script to:

Skip exporting PDFs for any crime types where no data is visible

Log which crime types were skipped for transparency

Would you like that added? Provide Feedback | View Changes | Contribute. You said:
I activated 
Burglary - Comm & Res 7-Day, 28-Day, YTD
Robbery 7-Day, 28-Day, YTD

the symbology shows. do you want me to remove the definition queries for those layers? ChatGPT said:
Yes ‚Äî please temporarily remove the definition queries for the six layers you listed:

Burglary - Comm & Res 7-Day, 28-Day, YTD

Robbery 7-Day, 28-Day, YTD

üîç Why? This helps us confirm whether:

The issue is with the definition query filtering out all features. Or the layer is misconfigured or disconnected (which it sounds like it isn‚Äôt). ‚úÖ What to Do:
Open each layer‚Äôs Properties > Definition Query tab. Remove the query or select ‚Äú<None>‚Äù. Check if features display on the map. If they appear ‚Äî great! We‚Äôll then know it‚Äôs just a query logic issue. Once done, let me know what you see, and we‚Äôll fix the query syntax accordingly. Provide Feedback | View Changes | Contribute. You said:
Uploaded image
Uploaded image
Uploaded image
the features show, also some of the layers had 2 definition queries
ChatGPT said:
Thanks for the detailed screenshots ‚Äî they clearly show the issue. The problem arises because the definition queries aren't being replaced ‚Äî instead, new ones are being added or switched between, causing confusion in visibility and symbology. ‚úÖ Here's What Needs to Happen in the Script:
We should remove all existing definition queries from each layer before applying the new one for that reporting cycle. üõ† Updated Code Block to Reset Definition Queries:
Insert this just before setting lyr.definitionQuery = query inside the loop where layers are updated:

# Remove existing definition queries
if hasattr(lyr, "listDefinitionQueries"):
    for dq in lyr.listDefinitionQueries():
        lyr.removeDefinitionQuery(dq.name)
Then proceed to assign the new query:

lyr.definitionQuery = query
üîÑ Summary of Fix:
The code will now clean out any previously saved queries, even if they were manually added. This ensures the layer has exactly one query, matching the current reporting period. It avoids legacy queries affecting the map output. Would you like me to integrate this into the complete working script for you? You said:
yes
ChatGPT said:
Great ‚Äî here is the updated and complete script that now ensures:

Existing definition queries are removed before applying new ones. Basemap and boundary layers stay visible for all exports. Layers are properly filtered and maps zoom to visible data. ‚úÖ **Final Script (with fix applied):
import arcpy
import pandas as pd
from datetime import datetime
import os

# Set paths
csv_path = r"C:\Users\carucci_r\OneDrive - City of Hackensack\_Hackensack_Data_Repository\Refrence\TimeSCRPT\DateRelated\7Day_28Day_Cycle_20250414.csv"
export_root = r"C:\Users\carucci_r\OneDrive - City of Hackensack\_25_SCRPA\TIME_Based\Reports"
project = arcpy.mp.ArcGISProject("CURRENT")
map_obj = project.listMaps()[0]  # Assumes one map in project

# Load cycle control table
cycle_df = pd.read_csv(csv_path)
if not any(cycle_df['Is_Due'] == True):
    raise ValueError("No cycle is marked as 'Is_Due = True' in the cycle table.") current_cycle = cycle_df[cycle_df['Is_Due'] == True].iloc[0]

# Extract dates and report name
seven_day_start = pd.to_datetime(current_cycle['7_Day_Start']).strftime('%Y-%m-%d')
seven_day_end = pd.to_datetime(current_cycle['7_Day_End']).strftime('%Y-%m-%d')
twenty_eight_day_start = pd.to_datetime(current_cycle['28_Day_Start']).strftime('%Y-%m-%d')
twenty_eight_day_end = pd.to_datetime(current_cycle['28_Day_End']).strftime('%Y-%m-%d')
ytd_start = '2024-12-31'
report_name = current_cycle['Report_Name']
report_due_date = pd.to_datetime(current_cycle['Report_Due_Date']).strftime('%Y_%m_%d')

# Create output folder for this report
report_folder = os.path.join(export_root, f"{report_name}_{report_due_date}")
os.makedirs(report_folder, exist_ok=True)

# Keywords per crime type
keywords_by_crime = {
    "Burglary - Auto": ['auto'],
    "Burglary - Comm & Res": ['residence', 'commercial'],
    "Robbery": ['robbery'],
    "Sexual Offenses": ['sexual'],
    "MV Theft": ['motor vehicle theft']
}

# SQL query builders
def build_sql(start_date, end_date, keywords):
    calltype_clause = " OR ".join([f"calltype LIKE '%{kw}%'" for kw in keywords])
    return (
        f"calldate >= date '{start_date}' AND calldate <= date '{end_date}' "
        f"AND disposition LIKE '%report%' AND ({calltype_clause})"
    )

def build_sql_ytd(keywords):
    calltype_clause = " OR ".join([f"calltype LIKE '%{kw}%'" for kw in keywords])
    return (
        f"calldate >= date '{ytd_start}' "
        f"AND disposition LIKE '%report%' AND ({calltype_clause})"
    )

# Construct layer-to-query map
layer_query_mapping = {}
for crime, keywords in keywords_by_crime.items():
    layer_query_mapping[f"{crime} 7-Day"] = build_sql(seven_day_start, seven_day_end, keywords)
    layer_query_mapping[f"{crime} 28-Day"] = build_sql(twenty_eight_day_start, twenty_eight_day_end, keywords)
    layer_query_mapping[f"{crime} YTD"] = build_sql_ytd(keywords)

# Remove existing queries and apply new ones
for layer_name, query in layer_query_mapping.items():
    lyr = map_obj.listLayers(layer_name)[0]
    if hasattr(lyr, "listDefinitionQueries"):
        for dq in lyr.listDefinitionQueries():
            lyr.removeDefinitionQuery(dq.name)
    lyr.definitionQuery = query

# Layout export
layout = [lyt for lyt in project.listLayouts() if lyt.name.lower().startswith("crime_reporting_layout")][0]
crime_types = list(keywords_by_crime.keys())

# Basemap layers that should remain visible
base_layers = ["City Boundaries", "Human Geography Dark Label", "Human Geography Dark Detail", "Human Geography Dark Base"]

for crime in crime_types:
    visible_layers = []

    # Set visibility for this crime group + basemap
    for lyr in map_obj.listLayers():
        if crime in lyr.name:
            lyr.visible = True
            visible_layers.append(lyr)
        elif any(base in lyr.name for base in base_layers):
            lyr.visible = True
        else:
            lyr.visible = False

    # Zoom to visible layers
    extent = None
    for lyr in visible_layers:
        try:
            ext = lyr.getExtent()
            if extent:
                extent = extent.union(ext)
            else:
                extent = ext
        except:
            continue

    if extent:
        map_obj.defaultCamera.setExtent(extent)

    # Export the layout
    out_name = f"{crime.replace(' ', '_')}_{report_name}_{report_due_date}.pdf"
    output_path = os.path.join(report_folder, out_name)
    layout.exportToPDF(output_path)

arcpy.AddMessage(f"Reports exported to: {report_folder}")
‚úÖ Summary of Improvements:
‚úÖ Cleans up legacy definition queries before applying new ones. ‚úÖ Keeps basemaps and city boundaries visible throughout. ‚úÖ Zooms maps to visible data. ‚úÖ Exports clean layouts into report-named folders. You can now run this from the template project without manually touching layers. Would you like me to help you set this script up as a scheduled task next? You said:
Updated code caused the below error:

ScriptWeekly Crime Report
=====================
Tool Path

C:\GIS_Tools\CrimeAutomationTools.tbx\WeeklyCrimeReport
=====================
Parameters

=====================
Messages

Start Time: Friday, May 2, 2025 7:46:53 PM
ÔªøTraceback (most recent call last):
Ôªø  File "C:\Users\carucci_r\OneDrive - City of Hackensack\_Hackensack_Data_Repository\Refrence\TimeSCRPT\Code\Python\weekly_crime_report.py", line 68, in <module>
Ôªø    lyr.removeDefinitionQuery(dq.name)
Ôªø    ^^^^^^^^^^^^^^^^^^^^^^^^^
ÔªøAttributeError: 'Layer' object has no attribute 'removeDefinitionQuery'. Did you mean: 'definitionQuery'? Failed script ScriptWeekly Crime Report...
Failed to execute (WeeklyCrimeReport). Failed at Friday, May 2, 2025 7:46:53 PM (Elapsed Time: 0.28 seconds)
ChatGPT said:
Thank you ‚Äî the issue is due to using a non-existent method removeDefinitionQuery, which doesn't exist in the ArcPy API for layers. ArcGIS Pro‚Äôs ArcPy only supports setting a single .definitionQuery ‚Äî it does not provide a method to remove named queries from the list as shown in the GUI. ‚úÖ Fix:
We‚Äôll remove that block and just overwrite the active .definitionQuery string instead. This is enough for our use case. Here‚Äôs the corrected snippet to replace lines 66‚Äì69 in your current script:

# Apply new definition queries (overwrite any existing one)
for layer_name, query in layer_query_mapping.items():
    lyr = map_obj.listLayers(layer_name)[0]
    lyr.definitionQuery = query
This will safely update the definition query without trying to remove anything. ‚úÖ No other changes are needed. Let me know when you‚Äôre ready to re-test or if you'd like me to insert this back into the full script. You said:
is this correct:

import arcpy
import pandas as pd
from datetime import datetime
import os

# Set paths
csv_path = r"C:\Users\carucci_r\OneDrive - City of Hackensack\_Hackensack_Data_Repository\Refrence\TimeSCRPT\DateRelated\7Day_28Day_Cycle_20250414.csv"
export_root = r"C:\Users\carucci_r\OneDrive - City of Hackensack\_25_SCRPA\TIME_Based\Reports"
project = arcpy.mp.ArcGISProject("CURRENT")
map_obj = project.listMaps()[0]  # Assumes one map in project

# Load cycle control table
cycle_df = pd.read_csv(csv_path)
if not any(cycle_df['Is_Due'] == True):
    raise ValueError("No cycle is marked as 'Is_Due = True' in the cycle table.") current_cycle = cycle_df[cycle_df['Is_Due'] == True].iloc[0]

# Extract dates and report name
seven_day_start = pd.to_datetime(current_cycle['7_Day_Start']).strftime('%Y-%m-%d')
seven_day_end = pd.to_datetime(current_cycle['7_Day_End']).strftime('%Y-%m-%d')
twenty_eight_day_start = pd.to_datetime(current_cycle['28_Day_Start']).strftime('%Y-%m-%d')
twenty_eight_day_end = pd.to_datetime(current_cycle['28_Day_End']).strftime('%Y-%m-%d')
ytd_start = '2024-12-31'
report_name = current_cycle['Report_Name']
report_due_date = pd.to_datetime(current_cycle['Report_Due_Date']).strftime('%Y_%m_%d')

# Create output folder for this report
report_folder = os.path.join(export_root, f"{report_name}_{report_due_date}")
os.makedirs(report_folder, exist_ok=True)

# Keywords per crime type
keywords_by_crime = {
    "Burglary - Auto": ['auto'],
    "Burglary - Comm & Res": ['residence', 'commercial'],
    "Robbery": ['robbery'],
    "Sexual Offenses": ['sexual'],
    "MV Theft": ['motor vehicle theft']
}

# SQL query builders
def build_sql(start_date, end_date, keywords):
    calltype_clause = " OR ".join([f"calltype LIKE '%{kw}%'" for kw in keywords])
    return (
        f"calldate >= date '{start_date}' AND calldate <= date '{end_date}' "
        f"AND disposition LIKE '%report%' AND ({calltype_clause})"
    )

def build_sql_ytd(keywords):
    calltype_clause = " OR ".join([f"calltype LIKE '%{kw}%'" for kw in keywords])
    return (
        f"calldate >= date '{ytd_start}' "
        f"AND disposition LIKE '%report%' AND ({calltype_clause})"
    )

# Construct layer-to-query map
layer_query_mapping = {}
for crime, keywords in keywords_by_crime.items():
    layer_query_mapping[f"{crime} 7-Day"] = build_sql(seven_day_start, seven_day_end, keywords)
    layer_query_mapping[f"{crime} 28-Day"] = build_sql(twenty_eight_day_start, twenty_eight_day_end, keywords)
    layer_query_mapping[f"{crime} YTD"] = build_sql_ytd(keywords)

# Remove existing queries and apply new ones
for layer_name, query in layer_query_mapping.items():
    lyr = map_obj.listLayers(layer_name)[0]
    ScriptWeekly Crime Report
=====================
Tool Path

C:\GIS_Tools\CrimeAutomationTools.tbx\WeeklyCrimeReport
=====================
Parameters

=====================
Messages

Start Time: Friday, May 2, 2025 7:46:53 PM
ÔªøTraceback (most recent call last):
Ôªø  File "C:\Users\carucci_r\OneDrive - City of Hackensack\_Hackensack_Data_Repository\Refrence\TimeSCRPT\Code\Python\weekly_crime_report.py", line 68, in <module>
Ôªø    lyr.removeDefinitionQuery(dq.name)
Ôªø    ^^^^^^^^^^^^^^^^^^^^^^^^^
ÔªøAttributeError: 'Layer' object has no attribute 'removeDefinitionQuery'. Did you mean: 'definitionQuery'? Failed script ScriptWeekly Crime Report...
Failed to execute (WeeklyCrimeReport). Failed at Friday, May 2, 2025 7:46:53 PM (Elapsed Time: 0.28 seconds)


# Layout export
layout = [lyt for lyt in project.listLayouts() if lyt.name.lower().startswith("crime_reporting_layout")][0]
crime_types = list(keywords_by_crime.keys())

# Basemap layers that should remain visible
base_layers = ["City Boundaries", "Human Geography Dark Label", "Human Geography Dark Detail", "Human Geography Dark Base"]

for crime in crime_types:
    visible_layers = []

    # Set visibility for this crime group + basemap
    for lyr in map_obj.listLayers():
        if crime in lyr.name:
            lyr.visible = True
            visible_layers.append(lyr)
        elif any(base in lyr.name for base in base_layers):
            lyr.visible = True
        else:
            lyr.visible = False

    # Zoom to visible layers
    extent = None
    for lyr in visible_layers:
        try:
            ext = lyr.getExtent()
            if extent:
                extent = extent.union(ext)
            else:
                extent = ext
        except:
            continue

    if extent:
        map_obj.defaultCamera.setExtent(extent)

    # Export the layout
    out_name = f"{crime.replace(' ', '_')}_{report_name}_{report_due_date}.pdf"
    output_path = os.path.join(report_folder, out_name)
    layout.exportToPDF(output_path)

arcpy.AddMessage(f"Reports exported to: {report_folder}")
ChatGPT said:
Thanks for sharing the updated code. I can confirm that most of it looks very solid and reflects our intended logic, except one portion was mistakenly left in, which is causing your current error. ‚ùå Issue
In this block:

# Remove existing queries and apply new ones
for layer_name, query in layer_query_mapping.items():
    lyr = map_obj.listLayers(layer_name)[0]
    ScriptWeekly Crime Report
You:

Left an accidental paste of a geoprocessing message (ScriptWeekly Crime Report) mid-script. Still reference lyr.removeDefinitionQuery(...) in the broken block above, which we previously confirmed is not valid in ArcPy. ‚úÖ Corrected Block
Replace that entire faulty block with the following, which simply overwrites the definition query:

# Apply definition queries (overwrite any existing one)
for layer_name, query in layer_query_mapping.items():
    lyr = map_obj.listLayers(layer_name)[0]
    lyr.definitionQuery = query
‚úÖ Final Notes
Your layout filtering by name (e.g., "Crime_Reporting_Layout") is correct and defensive. Your use of base_layers for persistent visibility is excellent. The extent calculation with union() is sound and error-tolerant. File naming is clear and formatted as expected. Would you like me to repackage this into a fully cleaned-up script block so you can copy/paste directly? You said:
yes
ChatGPT said:
Here is your fully cleaned, corrected, and ready-to-run script for the weekly crime report automation:

‚úÖ Final Weekly Crime Report Script (ArcGIS Pro Python)
import arcpy
import pandas as pd
from datetime import datetime
import os

# Set paths
csv_path = r"C:\Users\carucci_r\OneDrive - City of Hackensack\_Hackensack_Data_Repository\Refrence\TimeSCRPT\DateRelated\7Day_28Day_Cycle_20250414.csv"
export_root = r"C:\Users\carucci_r\OneDrive - City of Hackensack\_25_SCRPA\TIME_Based\Reports"
project = arcpy.mp.ArcGISProject("CURRENT")
map_obj = project.listMaps()[0]  # Assumes one map in project

# Load cycle control table
cycle_df = pd.read_csv(csv_path)
if not any(cycle_df['Is_Due'] == True):
    raise ValueError("No cycle is marked as 'Is_Due = True' in the cycle table.")