This is a powerful and insightful workflow, and ArcGIS Pro can absolutely handle this with the right combination of tools and Python scripting using ArcPy and pandas. Below is a breakdown of the steps, followed by an example script that automates the entire process:

⸻

Workflow Overview:
1. Access CAD Data from ArcGIS Online Portal. 2. Extract and parse address fields (e.g., "123 Main Street" becomes number = 123, block = "100 block of Main Street"). 3. Extract date and time components:
• Call Date
• Day of Week
• Hour
• Time of Day Category (custom groupings like “Early Morning”, “Rush Hour”, etc.) 4. Create a pivot table:
• Rows: Time of Day Categories
• Columns: Day of Week
• Values: Count of incidents
5. Export final result to a table (CSV or ArcGIS Table)

⸻

Sample Python Script (ArcGIS Pro, ArcPy + Pandas)

Ensure you run this in an ArcGIS Pro environment where you’re signed into your Portal. import arcpy
import pandas as pd
import re
from datetime import datetime

# Step 1: Set workspace and access CAD layer from Portal
arcpy.env.workspace = "YOUR_PROJECT_GDB_PATH"
cad_layer = "YOUR_PORTAL_ITEM_NAME" # Needs to be added to project or loaded via arcpy.mp

# Step 2: Convert to feature class if needed
output_fc = "cad_calls_fc"
if not arcpy.Exists(output_fc):
arcpy.conversion.FeatureClassToFeatureClass(cad_layer, arcpy.env.workspace, output_fc)

# Step 3: Convert to DataFrame
fields = ['CallDate', 'FullAddress']
df = pd.DataFrame(arcpy.da.TableToNumPyArray(output_fc, fields))

# Step 4: Parse date and time fields
df['CallDate'] = pd.to_datetime(df['CallDate'])
df['DayOfWeek'] = df['CallDate'].dt.day_name()
df['Hour'] = df['CallDate'].dt.hour

# Step 5: Custom time of day grouping
def categorize_time(hour):
if 0 <= hour <= 3:
return 'Early Morning'
elif 4 <= hour <= 7:
return 'Morning'
elif 8 <= hour <= 10:
return 'Rush Hour'
elif 11 <= hour <= 15:
return 'Afternoon'
elif 16 <= hour <= 19:
return 'Evening'
else:
return 'Night'

df['TimeOfDay'] = df['Hour'].apply(categorize_time)

# Step 6: Parse address fields
def parse_address(address):
match = re.match(r"(\d+)\s+(. *)", address)
if match:
num = int(match.group(1))
street = match.group(2)
block = f"{(num // 100) * 100} block of {street}"
return pd.Series([num, street, block])
return pd.Series([None, None, None])

df[['AddressNumber', 'StreetName', 'AddressBlock']] = df['FullAddress'].apply(parse_address)

# Step 7: Create pivot table
pivot_table = pd.pivot_table(df, index='TimeOfDay', columns='DayOfWeek', aggfunc='size', fill_value=0)

# Step 8: Export to CSV or ArcGIS Table
pivot_table.reset_index(inplace=True)
pivot_table.to_csv("incident_summary_table.csv", index=False)


⸻

Next Steps:
• Replace "YOUR_PROJECT_GDB_PATH" and "YOUR_PORTAL_ITEM_NAME" with your actual paths. • If you want to output this as a proper ArcGIS Table (instead of CSV), I can adjust the export accordingly. Great question — combining time of day, day of the week, and block address into a single summary table is absolutely doable using a multi-dimensional aggregation in pandas — specifically a pivot table with multiple index or column levels, or a groupby aggregation depending on how you’d like to structure it. ⸻

Goal Summary Table Structure Options:

Option 1: Multi-Index Pivot Table
• Index: Time of Day
• Columns: (Day of Week, Address Block)
• Values: Count of Incidents

This will produce a wide table with multi-level column headers, like:

Monday Tuesday ...
100 block of Main 200 block of Elm 100 block of Main ...
TimeOfDay
Early Morning 3 1 2
Morning 5 0 1
...

Option 2: Flat Table (GroupBy)

If you prefer a flat summary table that’s easier to export or visualize:

TimeOfDay DayOfWeek AddressBlock Count
Early Morning Monday 100 block of Main Street 3
Early Morning Monday 200 block of Elm Street 1
Morning Monday 100 block of Main Street 5
… … … …


⸻

How to Implement in Python:

Here’s how to build both formats:

1. Flat GroupBy Table

summary_df = df.groupby(['TimeOfDay', 'DayOfWeek', 'AddressBlock']).size().reset_index(name='Count')

2. Multi-Level Pivot Table

pivot_table = pd.pivot_table(
df,
index='TimeOfDay',
columns=['DayOfWeek', 'AddressBlock'],
aggfunc='size',
fill_value=0
)

To make it easier to export, you might want to flatten the multi-level columns:

pivot_table.columns = ['_'.join(col).strip() for col in pivot_table.columns.values]
pivot_table.reset_index(inplace=True)
Perfect — here’s a detailed walk-through including examples of both summary table formats and the final Python script you can run in ArcGIS Pro using ArcPy and pandas. ⸻

1. Table Format Examples

A. Flat Table using groupby()

Structure: Each row is a unique combination of time of day, day of week, and address block, with a count of incidents. TimeOfDay DayOfWeek AddressBlock Count
Early Morning Monday 100 block of Main St 4
Early Morning Monday 200 block of Elm Ave 2
Morning Tuesday 100 block of Main St 5
Afternoon Friday 300 block of Pine Blvd 1
… … … …

B. Pivot Table using pivot_table()

Structure: Rows are time of day, columns are combinations of day of week and address block. TimeOfDay Monday_100 block of Main St Monday_200 block of Elm Ave Tuesday_100 block of Main St …
Early Morning 4 2 0
Morning 1 0 5
Afternoon 0 0 0
… … … …


⸻

2. Final Python Script (ArcPy + pandas)

import arcpy
import pandas as pd
import re

# Set workspace and CAD layer
arcpy.env.workspace = "YOUR_PROJECT_GDB_PATH" # Replace with your GDB path
cad_layer = "YOUR_PORTAL_LAYER_NAME" # Replace with your Portal layer name

# Export CAD layer to feature class (if not already)
output_fc = "cad_calls_fc"
if not arcpy.Exists(output_fc):
arcpy.conversion.FeatureClassToFeatureClass(cad_layer, arcpy.env.workspace, output_fc)

# Convert to pandas DataFrame
fields = ['CallDate', 'FullAddress']
df = pd.DataFrame(arcpy.da.TableToNumPyArray(output_fc, fields))

# Parse datetime and extract components
df['CallDate'] = pd.to_datetime(df['CallDate'], errors='coerce')
df = df.dropna(subset=['CallDate'])
df['DayOfWeek'] = df['CallDate'].dt.day_name()
df['Hour'] = df['CallDate'].dt.hour

# Time of day categorization
def categorize_time(hour):
if 0 <= hour <= 3:
return 'Early Morning'
elif 4 <= hour <= 7:
return 'Morning'
elif 8 <= hour <= 10:
return 'Rush Hour'
elif 11 <= hour <= 15:
return 'Afternoon'
elif 16 <= hour <= 19:
return 'Evening'
else:
return 'Night'

df['TimeOfDay'] = df['Hour'].apply(categorize_time)

# Parse address block
def parse_address(address):
match = re.match(r"(\d+)\s+(. *)", address)
if match:
num = int(match.group(1))
street = match.group(2)
block = f"{(num // 100) * 100} block of {street}"
return pd.Series([num, street, block])
return pd.Series([None, None, None])

df[['AddressNumber', 'StreetName', 'AddressBlock']] = df['FullAddress'].apply(parse_address)

# Drop rows with missing block
df = df.dropna(subset=['AddressBlock'])

# === Flat summary table ===
flat_summary = df.groupby(['TimeOfDay', 'DayOfWeek', 'AddressBlock']).size().reset_index(name='Count')
flat_summary.to_csv("flat_summary.csv", index=False)

# === Pivot table summary ===
pivot_summary = pd.pivot_table(
df,
index='TimeOfDay',
columns=['DayOfWeek', 'AddressBlock'],
aggfunc='size',
fill_value=0
)

# Flatten multi-index columns for easier export
pivot_summary.columns = ['_'.join(col).replace(' ', '_') for col in pivot_summary.columns]
pivot_summary.reset_index(inplace=True)
pivot_summary.to_csv("pivot_summary.csv", index=False)
Absolutely — you can integrate this tabular summary directly into your automated map export workflow. Since you’re already exporting layouts as JPEGs, you can also render the summary tables (flat or pivot) as JPEG images and save them to the same folder, ready to drop into PowerPoint. Here’s a solution outline followed by updated script examples. ⸻

How to Include Summary Tables as JPEGs in Your Workflow
1. Use matplotlib to render the pandas DataFrame as a table. 2. Export the rendered table as a .jpg (or .png) image. 3. Run this logic after your existing symbology/map export logic, or integrate it into the same script. ⸻

Updated Python Script: Export Summary Tables as JPEGs

Add this snippet at the end of the previous script:

import matplotlib.pyplot as plt

def export_table_as_image(dataframe, image_path, title=None):
fig, ax = plt.subplots(figsize=(12, 6))
ax.axis('off')
table = ax.table(cellText=dataframe.values,
colLabels=dataframe.columns,
loc='center',
cellLoc='center')
table.auto_set_font_size(False)
table.set_fontsize(10)
table.scale(1.2, 1.2)

if title:
plt.title(title, fontsize=14, pad=20)

plt.tight_layout()
plt.savefig(image_path, dpi=300, bbox_inches='tight')
plt.close()

# Export tables as JPEG images for PowerPoint
export_table_as_image(flat_summary.head(20), 'flat_summary.jpg', title='Incident Summary - Flat Table')
export_table_as_image(pivot_summary.head(10), 'pivot_summary.jpg', title='Incident Summary - Pivot Table')

Tip: Use .head(20) or .head(10) to avoid overly large tables; adjust as needed. ⸻

Integration Options

You can integrate this directly into your layout export script like this:

# After exporting map layouts
arcpy.mp.ArcGISProject("CURRENT")
# Your layout export logic here...
# Then run the summary table logic

Or you can call both scripts from a master .py or .bat file using subprocess or scheduling with Windows Task Scheduler. ⸻

Automated Reporting Workflow Suggestions:
1. Folder structure: Create folders like /Reports/YYYY-MM-DD/ for each week’s output. 2. Exported content:
• Map_Monday.jpg, Map_Tuesday.jpg, …
• flat_summary.jpg
• pivot_summary.jpg
• flat_summary.csv
3. PowerPoint: Use a template where the table image is inserted in a fixed location each week. 4. Automation trigger: Schedule the script to run every Monday night or early Tuesday with Windows Task Scheduler or Task Sequence.