current_cycle = cycle_df[cycle_df['Is_Due'] == True].iloc[0]

# Extract dates and naming info
seven_day_start = pd.to_datetime(current_cycle['7_Day_Start']).strftime('%Y-%m-%d')
seven_day_end = pd.to_datetime(current_cycle['7_Day_End']).strftime('%Y-%m-%d')
twenty_eight_day_start = pd.to_datetime(current_cycle['28_Day_Start']).strftime('%Y-%m-%d')
twenty_eight_day_end = pd.to_datetime(current_cycle['28_Day_End']).strftime('%Y-%m-%d')
ytd_start = '2024-12-31'
report_name = current_cycle['Report_Name']
report_due_date = pd.to_datetime(current_cycle['Report_Due_Date']).strftime('%Y_%m_%d')

# Output folder
report_folder = os.path.join(export_root, f"{report_name}_{report_due_date}")
os.makedirs(report_folder, exist_ok=True)

# Keyword filters
keywords_by_crime = {
    "Burglary - Auto": ['auto'],
    "Burglary - Comm & Res": ['residence', 'commercial'],
    "Robbery": ['robbery'],
    "Sexual Offenses": ['sexual'],
    "MV Theft": ['motor vehicle theft']
}

# SQL definition builders
def build_sql(start_date, end_date, keywords):
    clause = " OR ".join([f"calltype LIKE '%{kw}%'" for kw in keywords])
    return f"calldate >= date '{start_date}' AND calldate <= date '{end_date}' AND disposition LIKE '%report%' AND ({clause})"

def build_sql_ytd(keywords):
    clause = " OR ".join([f"calltype LIKE '%{kw}%'" for kw in keywords])
    return f"calldate >= date '{ytd_start}' AND disposition LIKE '%report%' AND ({clause})"

# Apply definition queries
layer_query_mapping = {}
for crime, keywords in keywords_by_crime.items():
    layer_query_mapping[f"{crime} 7-Day"] = build_sql(seven_day_start, seven_day_end, keywords)
    layer_query_mapping[f"{crime} 28-Day"] = build_sql(twenty_eight_day_start, twenty_eight_day_end, keywords)
    layer_query_mapping[f"{crime} YTD"] = build_sql_ytd(keywords)

for lname, sql in layer_query_mapping.items():
    lyr = map_obj.listLayers(lname)[0]
    lyr.definitionQuery = sql

# Get layout
layout = [lyt for lyt in project.listLayouts() if lyt.name.lower().startswith("crime_reporting_layout")][0]
crime_types = list(keywords_by_crime.keys())
base_layers = ["City Boundaries", "Human Geography Dark Label", "Human Geography Dark Detail", "Human Geography Dark Base"]

# Per-crime PDF exports
for crime in crime_types:
    visible_layers = []

    for lyr in map_obj.listLayers():
        if crime in lyr.name:
            lyr.visible = True
            visible_layers.append(lyr)
            lyr.transparency = 0 if "7-Day" in lyr.name else 60
        elif any(base in lyr.name for base in base_layers):
            lyr.visible = True
        else:
            lyr.visible = False

    # Zoom to visible data (combined extent)
    extent = None
    for lyr in visible_layers:
        if lyr.supports("DATASOURCE"):
            with arcpy.da.SearchCursor(lyr, ["SHAPE@"]) as cursor:
                for row in cursor:
                    geom = row[0]
                    if extent:
                        extent = extent.combineExtent(geom.extent)
                    else:
                        extent = geom.extent
    if extent:
        map_obj.defaultCamera.setExtent(extent)

    # Refresh legend
    for legend in layout.listElements("LEGEND_ELEMENT"):
        legend.autoAdd = False
        for item in legend.listLegendItemLayers():
            legend.removeItem(item)
        for lyr in visible_layers:
            legend.addItem(lyr)

    # Export to PDF
    output_pdf = os.path.join(report_folder, f"{crime.replace(' ', '_')}_{report_name}_{report_due_date}.pdf")
    layout.exportToPDF(output_pdf)

arcpy.AddMessage(f"Reports exported to: {report_folder}")
Once you run it:

ðŸ“Œ All crime-specific layers and basemap layers will display. ðŸ“Œ Legend will be correctly regenerated per export. ðŸ“Œ Zoom will tightly fit the visible features using geometry extents. ðŸ“Œ Transparency: 60% for 28-Day and YTD, 0% for 7-Day. Would you like help testing this now? Provide Feedback | View Changes | Contribute. You said:
ScriptWeekly Crime Report
=====================
Tool Path

C:\GIS_Tools\CrimeAutomationTools.tbx\WeeklyCrimeReport
=====================
Parameters

=====================
Messages

Start Time: Friday, May 2, 2025 9:59:01 PM
ï»¿Traceback (most recent call last):
ï»¿  File "C:\Users\carucci_r\OneDrive - City of Hackensack\_Hackensack_Data_Repository\Refrence\TimeSCRPT\Code\Python\weekly_crime_report.py", line 87, in <module>
ï»¿    extent = extent.combineExtent(geom.extent)
ï»¿             ^^^^^^^^^^^^^^^^^^^^
ï»¿AttributeError: 'Extent' object has no attribute 'combineExtent'

Failed script ScriptWeekly Crime Report...
Failed to execute (WeeklyCrimeReport). Failed at Friday, May 2, 2025 9:59:07 PM (Elapsed Time: 5.96 seconds)
ChatGPT said:
Thanks for testing â€” and you're absolutely right. The method .combineExtent() does not exist on the Extent object in ArcPy. Instead, we'll use manual logic to combine extents. Hereâ€™s how to fix the error and finalize the extent union:

âœ… Replace the extent logic block with this:
# Zoom to visible data (combined extent)
extent = None
for lyr in visible_layers:
    if lyr.supports("DATASOURCE"):
        with arcpy.da.SearchCursor(lyr, ["SHAPE@"]) as cursor:
            for row in cursor:
                geom = row[0]
                if geom and geom.extent:
                    if extent is None:
                        extent = geom.extent
                    else:
                        extent = arcpy.Extent(
                            min(extent.XMin, geom.extent.XMin),
                            min(extent.YMin, geom.extent.YMin),
                            max(extent.XMax, geom.extent.XMax),
                            max(extent.YMax, geom.extent.YMax)
                        )
This safely computes the bounding box of all features without using non-existent methods. Would you like me to insert this fix into the full script again for you? Provide Feedback | View Changes | Contribute. You said:
yes
ChatGPT said:
Great. Here's the fully updated and corrected script with the working extent calculation logic, fixed legend handling, and your layout/export requirements integrated:

âœ… Final Script
import arcpy
import pandas as pd
from datetime import datetime
import os

# === Set paths ===
csv_path = r"C:\Users\carucci_r\OneDrive - City of Hackensack\_Hackensack_Data_Repository\Refrence\TimeSCRPT\DateRelated\7Day_28Day_Cycle_20250414.csv"
export_root = r"C:\Users\carucci_r\OneDrive - City of Hackensack\_25_SCRPA\TIME_Based\Reports"
project = arcpy.mp.ArcGISProject("CURRENT")
map_obj = project.listMaps()[0]

# === Load control table ===
cycle_df = pd.read_csv(csv_path)
if not any(cycle_df['Is_Due'] == True):
    raise ValueError("No cycle is marked as 'Is_Due = True' in the cycle table.") current_cycle = cycle_df[cycle_df['Is_Due'] == True].iloc[0]

# === Dates and naming ===
seven_day_start = pd.to_datetime(current_cycle['7_Day_Start']).strftime('%Y-%m-%d')
seven_day_end = pd.to_datetime(current_cycle['7_Day_End']).strftime('%Y-%m-%d')
twenty_eight_day_start = pd.to_datetime(current_cycle['28_Day_Start']).strftime('%Y-%m-%d')
twenty_eight_day_end = pd.to_datetime(current_cycle['28_Day_End']).strftime('%Y-%m-%d')
ytd_start = '2024-12-31'
report_name = current_cycle['Report_Name']
report_due_date = pd.to_datetime(current_cycle['Report_Due_Date']).strftime('%Y_%m_%d')

# === Output folder ===
report_folder = os.path.join(export_root, f"{report_name}_{report_due_date}")
os.makedirs(report_folder, exist_ok=True)

# === Filters ===
keywords_by_crime = {
    "Burglary - Auto": ['auto'],
    "Burglary - Comm & Res": ['residence', 'commercial'],
    "Robbery": ['robbery'],
    "Sexual Offenses": ['sexual'],
    "MV Theft": ['motor vehicle theft']
}

def build_sql(start, end, keywords):
    clause = " OR ".join([f"calltype LIKE '%{kw}%'" for kw in keywords])
    return f"calldate >= date '{start}' AND calldate <= date '{end}' AND disposition LIKE '%report%' AND ({clause})"

def build_sql_ytd(keywords):
    clause = " OR ".join([f"calltype LIKE '%{kw}%'" for kw in keywords])
    return f"calldate >= date '{ytd_start}' AND disposition LIKE '%report%' AND ({clause})"

# === Apply definition queries ===
layer_query_mapping = {}
for crime, kws in keywords_by_crime.items():
    layer_query_mapping[f"{crime} 7-Day"] = build_sql(seven_day_start, seven_day_end, kws)
    layer_query_mapping[f"{crime} 28-Day"] = build_sql(twenty_eight_day_start, twenty_eight_day_end, kws)
    layer_query_mapping[f"{crime} YTD"] = build_sql_ytd(kws)

for name, query in layer_query_mapping.items():
    lyr = map_obj.listLayers(name)[0]
    lyr.definitionQuery = query

# === Layout logic ===
layout = [lyt for lyt in project.listLayouts() if lyt.name.lower().startswith("crime_reporting_layout")][0]
crime_types = list(keywords_by_crime.keys())
base_layers = ["City Boundaries", "Human Geography Dark Label", "Human Geography Dark Detail", "Human Geography Dark Base"]

for crime in crime_types:
    visible_layers = []

    for lyr in map_obj.listLayers():
        if crime in lyr.name:
            lyr.visible = True
            visible_layers.append(lyr)
            lyr.transparency = 0 if "7-Day" in lyr.name else 60
        elif any(base in lyr.name for base in base_layers):
            lyr.visible = True
        else:
            lyr.visible = False

    # === Tighter zoom using geometry ===
    extent = None
    for lyr in visible_layers:
        if lyr.supports("DATASOURCE"):
            with arcpy.da.SearchCursor(lyr, ["SHAPE@"]) as cursor:
                for row in cursor:
                    geom = row[0]
                    if geom:
                        if extent is None:
                            extent = geom.extent
                        else:
                            extent = arcpy.Extent(
                                min(extent.XMin, geom.extent.XMin),
                                min(extent.YMin, geom.extent.YMin),
                                max(extent.XMax, geom.extent.XMax),
                                max(extent.YMax, geom.extent.YMax)
                            )
    if extent:
        map_obj.defaultCamera.setExtent(extent)

    # === Legend Update ===
    for legend in layout.listElements("LEGEND_ELEMENT"):
        legend.autoAdd = False
        for item in legend.listLegendItemLayers():
            legend.removeItem(item)
        for lyr in visible_layers:
            legend.addItem(lyr)

    # === Export layout ===
    output_pdf = os.path.join(report_folder, f"{crime.replace(' ', '_')}_{report_name}_{report_due_date}.pdf")
    layout.exportToPDF(output_pdf)

arcpy.AddMessage(f"Reports exported to: {report_folder}")
Key Fixes:
âœ” Extent properly calculated by combining feature bounds. âœ” Legend is rebuilt per export using only visible layers. âœ” Transparency set to 0% for 7-Day, 60% for 28-Day and YTD. âœ” Layouts are exported and stored in folders named using Report_Name_Report_Date. Let me know when you're ready to test this version. Provide Feedback | View Changes | Contribute. You said:
ScriptWeekly Crime Report
=====================
Tool Path

C:\GIS_Tools\CrimeAutomationTools.tbx\WeeklyCrimeReport
=====================
Parameters

=====================
Messages

Start Time: Friday, May 2, 2025 10:03:33 PM
ï»¿Traceback (most recent call last):
ï»¿  File "C:\Users\carucci_r\OneDrive - City of Hackensack\_Hackensack_Data_Repository\Refrence\TimeSCRPT\Code\Python\weekly_crime_report.py", line 100, in <module>
ï»¿    for item in legend.listLegendItemLayers():
ï»¿                ^^^^^^^^^^^^^^^^^^^^^^^^^^^
ï»¿AttributeError: 'LegendElement' object has no attribute 'listLegendItemLayers'

Failed script ScriptWeekly Crime Report...
Failed to execute (WeeklyCrimeReport). Failed at Friday, May 2, 2025 10:03:40 PM (Elapsed Time: 6.52 seconds)
ChatGPT said:
Thanks for testing and reporting back. The error confirms that LegendElement in ArcGIS Pro does not have the method listLegendItemLayers()â€”thatâ€™s on me. Instead, we should use legend.listItems() to remove individual items. Hereâ€™s how to fix that section:

âœ… REPLACE this block:
for item in legend.listLegendItemLayers():
    legend.removeItem(item)
ðŸš€ WITH this:
for item in legend.listItems():
    legend.removeItem(item)
I'll provide the corrected section of the script for convenience:

# === Legend Update ===
for legend in layout.listElements("LEGEND_ELEMENT"):
    legend.autoAdd = False
    for item in legend.listItems():
        legend.removeItem(item)
    for lyr in visible_layers:
        legend.addItem(lyr)
You're very close! After this fix, the legend should behave correctly. Let me know once you've updated and rerun it. Provide Feedback | View Changes | Contribute. You said:
ScriptWeekly Crime Report
=====================
Tool Path

C:\GIS_Tools\CrimeAutomationTools.tbx\WeeklyCrimeReport
=====================
Parameters

=====================
Messages

Start Time: Friday, May 2, 2025 10:06:22 PM
ï»¿Traceback (most recent call last):
ï»¿  File "C:\Users\carucci_r\OneDrive - City of Hackensack\_Hackensack_Data_Repository\Refrence\TimeSCRPT\Code\Python\weekly_crime_report.py", line 100, in <module>
ï»¿    for item in legend.listItems():
ï»¿                ^^^^^^^^^^^^^^^^
ï»¿AttributeError: 'LegendElement' object has no attribute 'listItems'

Failed script ScriptWeekly Crime Report...
Failed to execute (WeeklyCrimeReport). Failed at Friday, May 2, 2025 10:06:44 PM (Elapsed Time: 22.43 seconds)
ChatGPT said:
Thanks for your patience. ArcGIS Pro's LegendElement object indeed doesn't support listItems() or clear() directly, unlike MapFrame or GraphicsLayer. That limitation means we can't manipulate individual legend items with ArcPy like we hoped. âœ… Correct Approach:
Instead of clearing or managing items manually, you should preconfigure the legend in your layout to:

Auto-update: autoAdd = True

Use dynamic filtering by visible layers

Format as:

Single column

7-Day â†’ Layer Name only

28-Day & YTD â†’ Layer Name and Label

Then, during export, we let ArcGIS Pro handle legend content based on layer visibility. ðŸ”§ What to Change in the Script:
Remove the problematic legend section and use this instead:

# Ensure legend reflects visible layers (handled dynamically if layout is pre-configured)
for legend in layout.listElements("LEGEND_ELEMENT"):
    legend.autoAdd = True
    legend.refresh()
This lets your layoutâ€™s existing dynamic legend adjust automatically based on layer visibility each time the script runs. Would you like me to provide the complete corrected script with this integrated? Provide Feedback | View Changes | Contribute. You said:
yes
ChatGPT said:
Here is the full corrected script with the legend behavior adjusted as discussed. It also ensures:

Proper SQL filters per layer. Basemaps stay on. Symbology transparency is set (0% for 7-Day, 60% for 28-Day and YTD). Camera zooms to visible crime data. Legend auto-updates based on what is visible. import arcpy
import pandas as pd
from datetime import datetime
import os

# Paths
csv_path = r"C:\Users\carucci_r\OneDrive - City of Hackensack\_Hackensack_Data_Repository\Refrence\TimeSCRPT\DateRelated\7Day_28Day_Cycle_20250414.csv"
export_root = r"C:\Users\carucci_r\OneDrive - City of Hackensack\_25_SCRPA\TIME_Based\Reports"
project = arcpy.mp.ArcGISProject("CURRENT")
map_obj = project.listMaps()[0]

# Load control CSV
cycle_df = pd.read_csv(csv_path)
if not any(cycle_df['Is_Due'] == True):
    raise ValueError("No reporting cycle marked as 'Is_Due = True'.") current_cycle = cycle_df[cycle_df['Is_Due'] == True].iloc[0]
seven_day_start = pd.to_datetime(current_cycle['7_Day_Start']).strftime('%Y-%m-%d')
seven_day_end = pd.to_datetime(current_cycle['7_Day_End']).strftime('%Y-%m-%d')
twenty_eight_day_start = pd.to_datetime(current_cycle['28_Day_Start']).strftime('%Y-%m-%d')
twenty_eight_day_end = pd.to_datetime(current_cycle['28_Day_End']).strftime('%Y-%m-%d')
ytd_start = '2024-12-31'
report_name = current_cycle['Report_Name']
report_due_date = pd.to_datetime(current_cycle['Report_Due_Date']).strftime('%Y_%m_%d')

# Output folder
report_folder = os.path.join(export_root, f"{report_name}_{report_due_date}")
os.makedirs(report_folder, exist_ok=True)

# Filter keywords per crime type
keywords_by_crime = {
    "Burglary - Auto": ['auto'],
    "Burglary - Comm & Res": ['residence', 'commercial'],
    "Robbery": ['robbery'],
    "Sexual Offenses": ['sexual'],
    "MV Theft": ['motor vehicle theft']
}

# SQL builders
def build_sql(start_date, end_date, keywords):
    calltype_clause = " OR ".join([f"calltype LIKE '%{kw}%'" for kw in keywords])
    return f"calldate >= date '{start_date}' AND calldate <= date '{end_date}' AND disposition LIKE '%report%' AND ({calltype_clause})"

def build_sql_ytd(keywords):
    calltype_clause = " OR ".join([f"calltype LIKE '%{kw}%'" for kw in keywords])
    return f"calldate >= date '{ytd_start}' AND disposition LIKE '%report%' AND ({calltype_clause})"

# Apply filters
layer_query_mapping = {}
for crime, keywords in keywords_by_crime.items():
    layer_query_mapping[f"{crime} 7-Day"] = build_sql(seven_day_start, seven_day_end, keywords)
    layer_query_mapping[f"{crime} 28-Day"] = build_sql(twenty_eight_day_start, twenty_eight_day_end, keywords)
    layer_query_mapping[f"{crime} YTD"] = build_sql_ytd(keywords)

for lname, sql in layer_query_mapping.items():
    lyr = map_obj.listLayers(lname)[0]
    lyr.definitionQuery = sql

# Layout selection
layout = [lyt for lyt in project.listLayouts() if lyt.name.lower().startswith("crime_reporting_layout")][0]
crime_types = list(keywords_by_crime.keys())
base_layers = ["City Boundaries", "Human Geography Dark Label", "Human Geography Dark Detail", "Human Geography Dark Base"]

for crime in crime_types:
    visible_layers = []

    for lyr in map_obj.listLayers():
        if crime in lyr.name:
            lyr.visible = True
            visible_layers.append(lyr)
            lyr.transparency = 0 if "7-Day" in lyr.name else 60
        elif any(base in lyr.name for base in base_layers):
            lyr.visible = True
        else:
            lyr.visible = False

    # Zoom using extent of all visible features
    extent = None
    for lyr in visible_layers:
        if lyr.supports("DATASOURCE"):
            with arcpy.da.SearchCursor(lyr, ["SHAPE@"]) as cursor:
                for row in cursor:
                    geom = row[0]
                    if extent:
                        extent = extent.union(geom.extent)
                    else:
                        extent = geom.extent
    if extent:
        map_obj.defaultCamera.setExtent(extent)

    # Let legend auto-update based on visible layers
    for legend in layout.listElements("LEGEND_ELEMENT"):
        legend.autoAdd = True
        legend.refresh()

    # Export
    out_file = f"{crime.replace(' ', '_')}_{report_name}_{report_due_date}.pdf"
    layout.exportToPDF(os.path.join(report_folder, out_file))

arcpy.AddMessage(f"Reports exported to: {report_folder}")
Run this with the Crime_Reporting_Layout active in your template project. It should:

Show updated legend items. Zoom appropriately. Apply all transparency, filters, and export rules. Let me know when you're ready to test. Provide Feedback | View Changes | Contribute. You said:
ScriptWeekly Crime Report
=====================
Tool Path

C:\GIS_Tools\CrimeAutomationTools.tbx\WeeklyCrimeReport
=====================
Parameters

=====================
Messages

Start Time: Friday, May 2, 2025 10:11:20 PM

the layouts are not being exported 
ï»¿Traceback (most recent call last):
ï»¿  File "C:\Users\carucci_r\OneDrive - City of Hackensack\_Hackensack_Data_Repository\Refrence\TimeSCRPT\Code\Python\weekly_crime_report.py", line 85, in <module>
ï»¿    extent = extent.union(geom.extent)
ï»¿             ^^^^^^^^^^^^
ï»¿AttributeError: 'Extent' object has no attribute 'union'

Failed script ScriptWeekly Crime Report...
Failed to execute (WeeklyCrimeReport). Failed at Friday, May 2, 2025 10:11:26 PM (Elapsed Time: 6.46 seconds)
ChatGPT said:
Thank you â€” this error confirms that extent.union(...) is invalid for Extent objects in ArcPy. ArcPy Extent objects don't have a union() method. Instead, to merge multiple extents, we need to manually compute the combined min/max coordinates. Hereâ€™s the corrected logic for combining extents:

âœ… Replace this block (starting around line 82):
if extent:
    extent = extent.union(geom.extent)
else:
    extent = geom.extent
âœ… With this safe manual merge:
if extent:
    extent = arcpy.Extent(
        min(extent.XMin, geom.extent.XMin),
        min(extent.YMin, geom.extent.YMin),
        max(extent.XMax, geom.extent.XMax),
        max(extent.YMax, geom.extent.YMax)
    )
else:
    extent = geom.extent
ðŸ” Updated in Context:
Here's that section fully integrated:

# Zoom using extent of all visible features
extent = None
for lyr in visible_layers:
    if lyr.supports("DATASOURCE"):
        with arcpy.da.SearchCursor(lyr, ["SHAPE@"]) as cursor:
            for row in cursor:
                geom = row[0]
                if extent:
                    extent = arcpy.Extent(
                        min(extent.XMin, geom.extent.XMin),
                        min(extent.YMin, geom.extent.YMin),
                        max(extent.XMax, geom.extent.XMax),
                        max(extent.YMax, geom.extent.YMax)
                    )
                else:
                    extent = geom.extent
if extent:
    map_obj.defaultCamera.setExtent(extent)
Go ahead and update the script with this correction and rerun the tool. Let me know how the layout looks after this pass, especially with zoom and legend. Provide Feedback | View Changes | Contribute. You said:
is this script correct:


# Zoom using extent of all visible features
extent = None
for lyr in visible_layers:
    if lyr.supports("DATASOURCE"):
        with arcpy.da.SearchCursor(lyr, ["SHAPE@"]) as cursor:
            for row in cursor:
                geom = row[0]
                if extent:
                    extent = arcpy.Extent(
                        min(extent.XMin, geom.extent.XMin),
                        min(extent.YMin, geom.extent.YMin),
                        max(extent.XMax, geom.extent.XMax),
                        max(extent.YMax, geom.extent.YMax)
                    )
                else:
                    extent = geom.extent
if extent:
    map_obj.defaultCamera.setExtent(extent)
ChatGPT said:
Yes âœ… â€” the script you've posted is correct for calculating and setting the combined extent of visible feature layers in ArcPy. Here's what it does:

ðŸ” What It Does:
Iterates through visible_layers

Uses a SearchCursor to access geometries

Retrieves the extent (geom.extent) of each geometry

Builds a combined bounding box (arcpy.Extent) using the min/max X/Y values

Sets that as the map's extent with map_obj.defaultCamera.setExtent(extent)

âœ… Best Practices Already Used:
arcpy.da.SearchCursor for efficient geometry access

Defensive check with if extent: ... else: ... to build the union

Uses arcpy.Extent(...) constructor properly

ðŸ” One Tiny Suggestion (Optional):
If you want to skip empty geometry, you could add this inside the loop:

if not geom: continue
Let me know when you're ready to test this block in your script and move to exporting. Provide Feedback | View Changes | Contribute. You said:
provide the full script i deleted my version by mistake
ChatGPT said:

Analysis errored
Always show details

import textwrap

full_script = textwrap.dedent("""
    import arcpy
    import pandas as pd
    from datetime import datetime
    import os

    # Set paths
    csv_path = r"C:\\Users\\carucci_r\\OneDrive - City of Hackensack\\_Hackensack_Data_Repository\\Refrence\\TimeSCRPT\\DateRelated\\7Day_28Day_Cycle_20250414.csv"
    export_root = r"C:\\Users\\carucci_r\\OneDrive - City of Hackensack\\_25_SCRPA\\TIME_Based\\Reports"
    project = arcpy.mp.ArcGISProject("CURRENT")
    map_obj = project.listMaps()[0]  # Assumes one map in project

    # Load cycle control table
    cycle_df = pd.read_csv(csv_path)
    if not any(cycle_df['Is_Due'] == True):
        raise ValueError("No cycle is marked as 'Is_Due = True' in the cycle table.") current_cycle = cycle_df[cycle_df['Is_Due'] == True].iloc[0]

    # Extract dates and naming info
    seven_day_start = pd.to_datetime(current_cycle['7_Day_Start']).strftime('%Y-%m-%d')
    seven_day_end = pd.to_datetime(current_cycle['7_Day_End']).strftime('%Y-%m-%d')
    twenty_eight_day_start = pd.to_datetime(current_cycle['28_Day_Start']).strftime('%Y-%m-%d')
    twenty_eight_day_end = pd.to_datetime(current_cycle['28_Day_End']).strftime('%Y-%m-%d')
    ytd_start = '2024-12-31'
    report_name = current_cycle['Report_Name']
    report_due_date = pd.to_datetime(current_cycle['Report_Due_Date']).strftime('%Y_%m_%d')

    # Output folder
    report_folder = os.path.join(export_root, f"{report_name}_{report_due_date}")
    os.makedirs(report_folder, exist_ok=True)

    # Keyword filters
    keywords_by_crime = {
        "Burglary - Auto": ['auto'],
        "Burglary - Comm & Res": ['residence', 'commercial'],
        "Robbery": ['robbery'],
        "Sexual Offenses": ['sexual'],
        "MV Theft": ['motor vehicle theft']
    }

    def build_sql(start_date, end_date, keywords):
        clause = " OR ".join([f"calltype LIKE '%{kw}%'" for kw in keywords])
        return f"calldate >= date '{start_date}' AND calldate <= date '{end_date}' AND disposition LIKE '%report%' AND ({clause})"

    def build_sql_ytd(keywords):
        clause = " OR ".join([f"calltype LIKE '%{kw}%'" for kw in keywords])
        return f"calldate >= date '{ytd_start}' AND disposition LIKE '%report%' AND ({clause})"

    # Apply queries
    layer_query_mapping = {}
    for crime, keywords in keywords_by_crime.items():
        layer_query_mapping[f"{crime} 7-Day"] = build_sql(seven_day_start, seven_day_end, keywords)
        layer_query_mapping[f"{crime} 28-Day"] = build_sql(twenty_eight_day_start, twenty_eight_day_end, keywords)
        layer_query_mapping[f"{crime} YTD"] = build_sql_ytd(keywords)

    for lname, sql in layer_query_mapping.items():
        lyr = map_obj.listLayers(lname)[0]
        lyr.definitionQuery = sql

    layout = [lyt for lyt in project.listLayouts() if lyt.name.lower().startswith("crime_reporting_layout")][0]
    crime_types = list(keywords_by_crime.keys())
    base_layers = ["City Boundaries", "Human Geography Dark Label", "Human Geography Dark Detail", "Human Geography Dark Base"]

    for crime in crime_types:
        visible_layers = []
        for lyr in map_obj.listLayers():
            if crime in lyr.name:
                lyr.visible = True
                visible_layers.append(lyr)
                if "7-Day" in lyr.name:
                    lyr.transparency = 0
                else:
                    lyr.transparency = 60
            elif any(base in lyr.name for base in base_layers):
                lyr.visible = True
            else:
                lyr.visible = False

        # Zoom using extent of all visible features
        extent = None
        for lyr in visible_layers:
            if lyr.supports("DATASOURCE"):
                with arcpy.da.SearchCursor(lyr, ["SHAPE@"]) as cursor:
                    for row in cursor:
                        geom = row[0]
                        if not geom:
                            continue
                        if extent:
                            extent = arcpy.Extent(
                                min(extent.XMin, geom.extent.XMin),
                                min(extent.YMin, geom.extent.YMin),
                                max(extent.XMax, geom.extent.XMax),
                                max(extent.YMax, geom.extent.YMax)
                            )
                        else:
                            extent = geom.extent
        if extent:
            map_obj.defaultCamera.setExtent(extent)

        # Export layout
        output_pdf = os.path.join(report_folder, f"{crime.replace(' ', '_')}_{report_name}_{report_due_date}.pdf")
        layout.exportToPDF(output_pdf)

    arcpy.AddMessage(f"Reports exported to: {report_folder}")
""")

full_script

Analyzed
Always show details

import textwrap

full_script = textwrap.dedent("""
    import arcpy
    import pandas as pd
    from datetime import datetime
    import os

    # Set paths
    csv_path = r"C:\\Users\\carucci_r\\OneDrive - City of Hackensack\\_Hackensack_Data_Repository\\Refrence\\TimeSCRPT\\DateRelated\\7Day_28Day_Cycle_20250414.csv"
    export_root = r"C:\\Users\\carucci_r\\OneDrive - City of Hackensack\\_25_SCRPA\\TIME_Based\\Reports"
    project = arcpy.mp.ArcGISProject("CURRENT")
    map_obj = project.listMaps()[0]  # Assumes one map in project

    # Load cycle control table
    cycle_df = pd.read_csv(csv_path)
    if not any(cycle_df['Is_Due'] == True):
        raise ValueError("No cycle is marked as 'Is_Due = True' in the cycle table.")