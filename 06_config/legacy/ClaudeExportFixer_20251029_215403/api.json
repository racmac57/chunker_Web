{
  "uuid": "sample-api",
  "name": "Sample: API Design",
  "summary": "RESTful API best practices and error handling strategies",
  "created_at": "2024-01-12T11:00:00Z",
  "updated_at": "2024-01-12T11:30:00Z",
  "settings": {
    "preview_feature_uses_artifacts": false,
    "preview_feature_uses_latex": false,
    "enabled_artifacts_attachments": false
  },
  "is_starred": true,
  "current_leaf_message_uuid": "msg-api-2",
  "conversation_id": "sample-api",
  "chat_messages": [
    {
      "uuid": "msg-api-1",
      "index": 0,
      "sender": "human",
      "text": "What are the best practices for designing a RESTful API with proper error handling? I need to handle various types of errors gracefully.",
      "content": [
        {
          "type": "text",
          "text": "What are the best practices for designing a RESTful API with proper error handling? I need to handle various types of errors gracefully."
        }
      ],
      "created_at": "2024-01-12T11:00:00Z",
      "updated_at": "2024-01-12T11:00:00Z",
      "truncated": false
    },
    {
      "uuid": "msg-api-2",
      "index": 1,
      "sender": "assistant",
      "text": "I'll guide you through RESTful API design best practices with comprehensive error handling.\n\n## Core REST Principles\n\n### 1. Use Proper HTTP Methods\n\n```python\nfrom fastapi import FastAPI, HTTPException, status\nfrom pydantic import BaseModel\n\napp = FastAPI()\n\nclass Item(BaseModel):\n    name: str\n    price: float\n    description: str = None\n\n# GET - Retrieve resources\n@app.get(\"/items/{item_id}\")\nasync def get_item(item_id: int):\n    if item_id not in database:\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND,\n            detail=\"Item not found\"\n        )\n    return database[item_id]\n\n# POST - Create new resources\n@app.post(\"/items\", status_code=status.HTTP_201_CREATED)\nasync def create_item(item: Item):\n    try:\n        new_item = save_to_database(item)\n        return new_item\n    except ValueError as error:\n        raise HTTPException(\n            status_code=status.HTTP_400_BAD_REQUEST,\n            detail=str(error)\n        )\n```\n\n## 2. Consistent Error Response Format\n\n```python\nfrom datetime import datetime\nfrom typing import Optional, List\n\nclass ErrorResponse(BaseModel):\n    error: str\n    message: str\n    status_code: int\n    timestamp: datetime\n    path: str\n    details: Optional[List[dict]] = None\n\n@app.exception_handler(HTTPException)\nasync def http_exception_handler(request, exc):\n    return JSONResponse(\n        status_code=exc.status_code,\n        content={\n            \"error\": exc.__class__.__name__,\n            \"message\": exc.detail,\n            \"status_code\": exc.status_code,\n            \"timestamp\": datetime.utcnow().isoformat(),\n            \"path\": str(request.url)\n        }\n    )\n```\n\n## 3. Status Codes Best Practices\n\n```python\n# Success Codes\n200 OK              # Successful GET, PUT\n201 Created         # Successful POST\n204 No Content      # Successful DELETE\n\n# Client Error Codes\n400 Bad Request     # Invalid syntax or validation error\n401 Unauthorized    # Authentication required\n403 Forbidden       # Authenticated but not authorized\n404 Not Found       # Resource doesn't exist\n409 Conflict        # Resource conflict (duplicate)\n422 Unprocessable   # Validation errors\n429 Too Many Requests # Rate limiting\n\n# Server Error Codes\n500 Internal Server Error  # Generic server error\n503 Service Unavailable  # Server overload/maintenance\n```\n\n## 4. Validation and Error Details\n\n```python\nfrom pydantic import validator, ValidationError\n\nclass Item(BaseModel):\n    name: str\n    price: float\n    quantity: int\n    \n    @validator('price')\n    def price_must_be_positive(cls, v):\n        if v <= 0:\n            raise ValueError('Price must be positive')\n        return v\n\n@app.exception_handler(ValidationError)\nasync def validation_exception_handler(request, exc):\n    errors = []\n    for error in exc.errors():\n        errors.append({\n            \"field\": \".\".join(str(loc) for loc in error[\"loc\"]),\n            \"message\": error[\"msg\"],\n            \"type\": error[\"type\"]\n        })\n    \n    return JSONResponse(\n        status_code=422,\n        content={\n            \"error\": \"ValidationError\",\n            \"message\": \"Request validation failed\",\n            \"details\": errors\n        }\n    )\n```\n\n## 5. Global Error Handling\n\n```python\n@app.exception_handler(Exception)\nasync def global_exception_handler(request, exc):\n    # Log the error for debugging\n    logger.error(f\"Unhandled error: {exc}\", exc_info=True)\n    \n    # Don't expose internal errors to clients\n    return JSONResponse(\n        status_code=500,\n        content={\n            \"error\": \"InternalServerError\",\n            \"message\": \"An unexpected error occurred\",\n            \"timestamp\": datetime.utcnow().isoformat()\n        }\n    )\n```\n\n## Best Practices Summary:\n\n1. **Use proper HTTP methods and status codes**\n2. **Return consistent error formats**\n3. **Include detailed error messages for debugging**\n4. **Validate input data thoroughly**\n5. **Handle errors at multiple levels**\n6. **Log errors for monitoring**\n7. **Don't expose sensitive information in error messages**\n8. **Use correlation IDs for tracking**\n9. **Implement rate limiting**\n10. **Document all error responses in your API docs**\n\nThis approach ensures your API handles errors gracefully and provides useful feedback to clients!",
      "content": [
        {
          "type": "text",
          "text": "I'll guide you through RESTful API design best practices with comprehensive error handling.\n\n## Core REST Principles\n\n### 1. Use Proper HTTP Methods\n\n```python\nfrom fastapi import FastAPI, HTTPException, status\nfrom pydantic import BaseModel\n\napp = FastAPI()\n\nclass Item(BaseModel):\n    name: str\n    price: float\n    description: str = None\n\n# GET - Retrieve resources\n@app.get(\"/items/{item_id}\")\nasync def get_item(item_id: int):\n    if item_id not in database:\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND,\n            detail=\"Item not found\"\n        )\n    return database[item_id]\n\n# POST - Create new resources\n@app.post(\"/items\", status_code=status.HTTP_201_CREATED)\nasync def create_item(item: Item):\n    try:\n        new_item = save_to_database(item)\n        return new_item\n    except ValueError as error:\n        raise HTTPException(\n            status_code=status.HTTP_400_BAD_REQUEST,\n            detail=str(error)\n        )\n```\n\n## 2. Consistent Error Response Format\n\n```python\nfrom datetime import datetime\nfrom typing import Optional, List\n\nclass ErrorResponse(BaseModel):\n    error: str\n    message: str\n    status_code: int\n    timestamp: datetime\n    path: str\n    details: Optional[List[dict]] = None\n\n@app.exception_handler(HTTPException)\nasync def http_exception_handler(request, exc):\n    return JSONResponse(\n        status_code=exc.status_code,\n        content={\n            \"error\": exc.__class__.__name__,\n            \"message\": exc.detail,\n            \"status_code\": exc.status_code,\n            \"timestamp\": datetime.utcnow().isoformat(),\n            \"path\": str(request.url)\n        }\n    )\n```\n\n## 3. Status Codes Best Practices\n\n```python\n# Success Codes\n200 OK              # Successful GET, PUT\n201 Created         # Successful POST\n204 No Content      # Successful DELETE\n\n# Client Error Codes\n400 Bad Request     # Invalid syntax or validation error\n401 Unauthorized    # Authentication required\n403 Forbidden       # Authenticated but not authorized\n404 Not Found       # Resource doesn't exist\n409 Conflict        # Resource conflict (duplicate)\n422 Unprocessable   # Validation errors\n429 Too Many Requests # Rate limiting\n\n# Server Error Codes\n500 Internal Server Error  # Generic server error\n503 Service Unavailable  # Server overload/maintenance\n```\n\n## 4. Validation and Error Details\n\n```python\nfrom pydantic import validator, ValidationError\n\nclass Item(BaseModel):\n    name: str\n    price: float\n    quantity: int\n    \n    @validator('price')\n    def price_must_be_positive(cls, v):\n        if v <= 0:\n            raise ValueError('Price must be positive')\n        return v\n\n@app.exception_handler(ValidationError)\nasync def validation_exception_handler(request, exc):\n    errors = []\n    for error in exc.errors():\n        errors.append({\n            \"field\": \".\".join(str(loc) for loc in error[\"loc\"]),\n            \"message\": error[\"msg\"],\n            \"type\": error[\"type\"]\n        })\n    \n    return JSONResponse(\n        status_code=422,\n        content={\n            \"error\": \"ValidationError\",\n            \"message\": \"Request validation failed\",\n            \"details\": errors\n        }\n    )\n```\n\n## 5. Global Error Handling\n\n```python\n@app.exception_handler(Exception)\nasync def global_exception_handler(request, exc):\n    # Log the error for debugging\n    logger.error(f\"Unhandled error: {exc}\", exc_info=True)\n    \n    # Don't expose internal errors to clients\n    return JSONResponse(\n        status_code=500,\n        content={\n            \"error\": \"InternalServerError\",\n            \"message\": \"An unexpected error occurred\",\n            \"timestamp\": datetime.utcnow().isoformat()\n        }\n    )\n```\n\n## Best Practices Summary:\n\n1. **Use proper HTTP methods and status codes**\n2. **Return consistent error formats**\n3. **Include detailed error messages for debugging**\n4. **Validate input data thoroughly**\n5. **Handle errors at multiple levels**\n6. **Log errors for monitoring**\n7. **Don't expose sensitive information in error messages**\n8. **Use correlation IDs for tracking**\n9. **Implement rate limiting**\n10. **Document all error responses in your API docs**\n\nThis approach ensures your API handles errors gracefully and provides useful feedback to clients!"
        }
      ],
      "created_at": "2024-01-12T11:15:00Z",
      "updated_at": "2024-01-12T11:15:00Z",
      "truncated": false
    }
  ]
}
